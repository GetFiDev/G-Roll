# Phase 1: Infrastructure Foundation

**Referans:** [01_ARCHITECTURE_ANALYSIS_REPORT.md](01_ARCHITECTURE_ANALYSIS_REPORT.md)
**Önkoşul:** [00_OPTIMISTIC_CLIENT_ARCHITECTURE.md](00_OPTIMISTIC_CLIENT_ARCHITECTURE.md)
**Versiyon:** 1.0
**Tahmini Kapsam:** Core infrastructure kurulumu

---

## EXECUTIVE SUMMARY

Bu döküman, G-Roll projesinin mimari refactoring'inin ilk fazını tanımlar. Bu faz, sonraki tüm fazların üzerine inşa edeceği **altyapı katmanını** kurar:

1. **Dependency Injection Container** - VContainer entegrasyonu
2. **Unified Event System** - MessageBus implementasyonu
3. **Base Classes** - Optimistic operation infrastructure
4. **Core Interfaces** - Tüm servisler için interface tanımları

---

## PRE-FLIGHT CHECKLIST

Bu faza başlamadan önce:

- [ ] Mevcut proje Git'e commit edilmiş olmalı
- [ ] Yeni bir branch oluşturulmalı: `refactor/phase-1-infrastructure`
- [ ] Unity 2022+ ve .NET Standard 2.1 uyumluluğu kontrol edilmeli
- [ ] Mevcut test coverage (varsa) çalışır durumda olmalı

---

## BÖLÜM 1: DEPENDENCY INJECTION SETUP

### 1.1 VContainer Kurulumu

**Neden VContainer?**
- Unity için optimize edilmiş
- Minimal GC allocation
- Source generator desteği
- Zenject'e göre daha hafif

**Kurulum Adımları:**

```
1. Package Manager → Add package from git URL:
   https://github.com/hadashiA/VContainer.git?path=VContainer/Assets/VContainer#1.15.4

2. Alternatif olarak manifest.json'a ekle:
   "jp.hadashikick.vcontainer": "https://github.com/hadashiA/VContainer.git?path=VContainer/Assets/VContainer#1.15.4"
```

### 1.2 Folder Structure

```
Assets/_Core/
├── DI/
│   ├── Installers/
│   │   ├── RootLifetimeScope.cs        # DontDestroyOnLoad scope
│   │   ├── GameSceneLifetimeScope.cs   # Game scene scope
│   │   └── BootSceneLifetimeScope.cs   # Boot scene scope
│   ├── Extensions/
│   │   └── VContainerExtensions.cs     # Helper extensions
│   └── README.md                        # DI kullanım kılavuzu
├── Events/
│   ├── Core/
│   │   ├── IMessageBus.cs
│   │   ├── MessageBus.cs
│   │   └── IMessage.cs
│   ├── Messages/
│   │   ├── GamePhaseChangedMessage.cs
│   │   ├── CurrencyChangedMessage.cs
│   │   └── ... (diğer message tipleri)
│   └── README.md
├── Optimistic/
│   ├── Core/
│   │   ├── ISnapshotable.cs
│   │   ├── IOptimisticOperation.cs
│   │   ├── OptimisticOperationBase.cs
│   │   └── OperationResult.cs
│   ├── Strategies/
│   │   ├── IRollbackStrategy.cs
│   │   ├── IFallbackStrategy.cs
│   │   └── DefaultStrategies.cs
│   └── README.md
└── Interfaces/
    ├── Services/
    │   ├── IAuthService.cs
    │   ├── ICurrencyService.cs
    │   ├── IInventoryService.cs
    │   ├── IAchievementService.cs
    │   ├── ITaskService.cs
    │   ├── ISessionService.cs
    │   ├── IEnergyService.cs
    │   └── ILeaderboardService.cs
    ├── UI/
    │   ├── INavigationService.cs
    │   ├── IFeedbackService.cs
    │   └── IDialogService.cs
    └── README.md
```

### 1.3 Root Lifetime Scope

```csharp
// Assets/_Core/DI/Installers/RootLifetimeScope.cs
using VContainer;
using VContainer.Unity;

/// <summary>
/// Application-wide DI container. DontDestroyOnLoad scope.
/// Bu scope tüm uygulama boyunca yaşar ve scene geçişlerinde korunur.
/// </summary>
public class RootLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        // ═══════════════════════════════════════════════════════════════
        // CORE SERVICES (Application Lifetime)
        // ═══════════════════════════════════════════════════════════════

        // Message Bus - Singleton, tüm uygulama boyunca
        builder.Register<IMessageBus, MessageBus>(Lifetime.Singleton);

        // Logger - Singleton
        builder.Register<ILogger, UnityLogger>(Lifetime.Singleton);

        // ═══════════════════════════════════════════════════════════════
        // INFRASTRUCTURE SERVICES
        // ═══════════════════════════════════════════════════════════════

        // Network Monitor - Singleton
        builder.Register<INetworkMonitor, NetworkMonitor>(Lifetime.Singleton);

        // Local Storage - Singleton
        builder.Register<ILocalStorage, PlayerPrefsStorage>(Lifetime.Singleton);

        // Main Thread Dispatcher - Singleton
        builder.Register<IMainThreadDispatcher, MainThreadDispatcher>(Lifetime.Singleton);

        // ═══════════════════════════════════════════════════════════════
        // AUTH & USER SERVICES (Firebase)
        // ═══════════════════════════════════════════════════════════════

        // Auth Service - Singleton (Firebase Auth wrapper)
        builder.Register<IAuthService, FirebaseAuthService>(Lifetime.Singleton);

        // User Profile Service - Singleton
        builder.Register<IUserProfileService, FirebaseUserProfileService>(Lifetime.Singleton);

        // ═══════════════════════════════════════════════════════════════
        // FEEDBACK SERVICES
        // ═══════════════════════════════════════════════════════════════

        // Haptic Service - Singleton
        builder.Register<IHapticService, HapticService>(Lifetime.Singleton);

        // Analytics Service - Singleton
        builder.Register<IAnalyticsService, FirebaseAnalyticsService>(Lifetime.Singleton);
    }
}
```

### 1.4 Game Scene Lifetime Scope

```csharp
// Assets/_Core/DI/Installers/GameSceneLifetimeScope.cs
using VContainer;
using VContainer.Unity;

/// <summary>
/// Game Scene specific DI container.
/// Bu scope Game Scene'e özgü servisler için.
/// Parent olarak RootLifetimeScope'u kullanır.
/// </summary>
public class GameSceneLifetimeScope : LifetimeScope
{
    [SerializeField] private PlayerSpawnerBehaviour playerSpawnerBehaviour;
    [SerializeField] private MapLoaderBehaviour mapLoaderBehaviour;

    protected override void Configure(IContainerBuilder builder)
    {
        // ═══════════════════════════════════════════════════════════════
        // GAME DATA SERVICES (Scene Lifetime)
        // ═══════════════════════════════════════════════════════════════

        // Currency Service - Scoped (scene lifetime)
        builder.Register<ICurrencyService, CurrencyService>(Lifetime.Scoped);

        // Inventory Service - Scoped
        builder.Register<IInventoryService, InventoryService>(Lifetime.Scoped);

        // Achievement Service - Scoped
        builder.Register<IAchievementService, AchievementService>(Lifetime.Scoped);

        // Task Service - Scoped
        builder.Register<ITaskService, TaskService>(Lifetime.Scoped);

        // Energy Service - Scoped
        builder.Register<IEnergyService, EnergyService>(Lifetime.Scoped);

        // Session Service - Scoped
        builder.Register<ISessionService, SessionService>(Lifetime.Scoped);

        // Leaderboard Service - Scoped
        builder.Register<ILeaderboardService, LeaderboardService>(Lifetime.Scoped);

        // ═══════════════════════════════════════════════════════════════
        // GAMEPLAY SERVICES
        // ═══════════════════════════════════════════════════════════════

        // Player Spawner - Component instance
        builder.RegisterComponent<IPlayerSpawner>(playerSpawnerBehaviour);

        // Map Loader - Component instance
        builder.RegisterComponent<IMapLoader>(mapLoaderBehaviour);

        // Game Manager - EntryPoint
        builder.RegisterEntryPoint<GameManager>();

        // Gameplay Manager - EntryPoint
        builder.RegisterEntryPoint<GameplayManager>();

        // ═══════════════════════════════════════════════════════════════
        // UI SERVICES
        // ═══════════════════════════════════════════════════════════════

        // Navigation Service - Scoped
        builder.Register<INavigationService, NavigationService>(Lifetime.Scoped);

        // Dialog Service - Scoped
        builder.Register<IDialogService, DialogService>(Lifetime.Scoped);

        // Feedback Service - Scoped
        builder.Register<IFeedbackService, FeedbackService>(Lifetime.Scoped);
    }
}
```

### 1.5 Migration Strategy: Singleton → DI

Mevcut Singleton'ları kademeli olarak DI'a taşımak için:

**Adım 1: Interface Oluştur**
```csharp
// Mevcut
public class GameplayManager : MonoBehaviour
{
    public static GameplayManager Instance;
    public void BeginSession() { ... }
}

// Yeni interface
public interface IGameplayManager
{
    void BeginSession();
    event Action<SessionState> OnSessionStateChanged;
}
```

**Adım 2: Bridge Pattern ile Geçici Çözüm**
```csharp
// Geçiş döneminde hem Singleton hem DI destekle
public class GameplayManager : MonoBehaviour, IGameplayManager
{
    public static GameplayManager Instance; // Geçici, kaldırılacak

    [Inject] private ISessionService _sessionService;
    [Inject] private IMessageBus _messageBus;

    void Awake()
    {
        // Geçici backward compatibility
        if (Instance == null) Instance = this;
    }

    // IGameplayManager implementation
    public void BeginSession() { ... }
}
```

**Adım 3: Consumer'ları Güncelle**
```csharp
// Eski kod
GameplayManager.Instance.BeginSession();

// Yeni kod
public class SomeConsumer : MonoBehaviour
{
    [Inject] private IGameplayManager _gameplayManager;

    void Start()
    {
        _gameplayManager.BeginSession();
    }
}
```

**Adım 4: Singleton'ı Kaldır**
```csharp
// Final hali - Singleton yok
public class GameplayManager : IGameplayManager
{
    private readonly ISessionService _sessionService;
    private readonly IMessageBus _messageBus;

    public GameplayManager(ISessionService sessionService, IMessageBus messageBus)
    {
        _sessionService = sessionService;
        _messageBus = messageBus;
    }
}
```

---

## BÖLÜM 2: MESSAGE BUS IMPLEMENTATION

### 2.1 Core Interfaces

```csharp
// Assets/_Core/Events/Core/IMessage.cs
/// <summary>
/// Tüm message tipleri için marker interface.
/// </summary>
public interface IMessage { }

/// <summary>
/// Timestamp içeren message'lar için.
/// </summary>
public interface ITimestampedMessage : IMessage
{
    DateTime Timestamp { get; }
}
```

```csharp
// Assets/_Core/Events/Core/IMessageBus.cs
using System;

/// <summary>
/// Type-safe publish/subscribe message bus.
/// Memory leak önlemek için IDisposable subscription döndürür.
/// </summary>
public interface IMessageBus
{
    /// <summary>
    /// Message yayınlar. Tüm subscriber'lara senkron olarak iletilir.
    /// </summary>
    void Publish<T>(T message) where T : IMessage;

    /// <summary>
    /// Message tipine subscribe olur.
    /// Dönen IDisposable dispose edildiğinde subscription iptal edilir.
    /// </summary>
    IDisposable Subscribe<T>(Action<T> handler) where T : IMessage;

    /// <summary>
    /// Async message yayınlar. Tüm async subscriber'ları bekler.
    /// </summary>
    UniTask PublishAsync<T>(T message) where T : IMessage;

    /// <summary>
    /// Async handler ile subscribe olur.
    /// </summary>
    IDisposable SubscribeAsync<T>(Func<T, UniTask> handler) where T : IMessage;
}
```

### 2.2 MessageBus Implementation

```csharp
// Assets/_Core/Events/Core/MessageBus.cs
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

public class MessageBus : IMessageBus
{
    private readonly Dictionary<Type, List<Delegate>> _handlers = new();
    private readonly Dictionary<Type, List<Delegate>> _asyncHandlers = new();
    private readonly object _lock = new();

    public void Publish<T>(T message) where T : IMessage
    {
        if (message == null) throw new ArgumentNullException(nameof(message));

        List<Delegate> handlers;
        lock (_lock)
        {
            if (!_handlers.TryGetValue(typeof(T), out handlers))
                return;

            // Copy to avoid modification during iteration
            handlers = new List<Delegate>(handlers);
        }

        foreach (var handler in handlers)
        {
            try
            {
                ((Action<T>)handler)(message);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[MessageBus] Handler error for {typeof(T).Name}: {ex}");
            }
        }
    }

    public IDisposable Subscribe<T>(Action<T> handler) where T : IMessage
    {
        if (handler == null) throw new ArgumentNullException(nameof(handler));

        lock (_lock)
        {
            if (!_handlers.ContainsKey(typeof(T)))
                _handlers[typeof(T)] = new List<Delegate>();

            _handlers[typeof(T)].Add(handler);
        }

        return new Subscription(() =>
        {
            lock (_lock)
            {
                if (_handlers.TryGetValue(typeof(T), out var list))
                    list.Remove(handler);
            }
        });
    }

    public async UniTask PublishAsync<T>(T message) where T : IMessage
    {
        if (message == null) throw new ArgumentNullException(nameof(message));

        // First, publish to sync handlers
        Publish(message);

        // Then, publish to async handlers
        List<Delegate> asyncHandlers;
        lock (_lock)
        {
            if (!_asyncHandlers.TryGetValue(typeof(T), out asyncHandlers))
                return;

            asyncHandlers = new List<Delegate>(asyncHandlers);
        }

        var tasks = new List<UniTask>();
        foreach (var handler in asyncHandlers)
        {
            tasks.Add(((Func<T, UniTask>)handler)(message));
        }

        await UniTask.WhenAll(tasks);
    }

    public IDisposable SubscribeAsync<T>(Func<T, UniTask> handler) where T : IMessage
    {
        if (handler == null) throw new ArgumentNullException(nameof(handler));

        lock (_lock)
        {
            if (!_asyncHandlers.ContainsKey(typeof(T)))
                _asyncHandlers[typeof(T)] = new List<Delegate>();

            _asyncHandlers[typeof(T)].Add(handler);
        }

        return new Subscription(() =>
        {
            lock (_lock)
            {
                if (_asyncHandlers.TryGetValue(typeof(T), out var list))
                    list.Remove(handler);
            }
        });
    }

    private class Subscription : IDisposable
    {
        private Action _unsubscribe;
        private bool _disposed;

        public Subscription(Action unsubscribe)
        {
            _unsubscribe = unsubscribe;
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
            _unsubscribe?.Invoke();
            _unsubscribe = null;
        }
    }
}
```

### 2.3 Common Message Types

```csharp
// Assets/_Core/Events/Messages/GamePhaseChangedMessage.cs
public readonly struct GamePhaseChangedMessage : IMessage
{
    public GamePhase PreviousPhase { get; }
    public GamePhase NewPhase { get; }

    public GamePhaseChangedMessage(GamePhase previous, GamePhase newPhase)
    {
        PreviousPhase = previous;
        NewPhase = newPhase;
    }
}

// Assets/_Core/Events/Messages/CurrencyChangedMessage.cs
public readonly struct CurrencyChangedMessage : IMessage
{
    public CurrencyType Type { get; }
    public int PreviousAmount { get; }
    public int NewAmount { get; }
    public int Delta => NewAmount - PreviousAmount;
    public bool IsOptimistic { get; }

    public CurrencyChangedMessage(CurrencyType type, int previous, int newAmount, bool isOptimistic = false)
    {
        Type = type;
        PreviousAmount = previous;
        NewAmount = newAmount;
        IsOptimistic = isOptimistic;
    }
}

// Assets/_Core/Events/Messages/InventoryChangedMessage.cs
public readonly struct InventoryChangedMessage : IMessage
{
    public InventoryChangeType ChangeType { get; }
    public string ItemId { get; }
    public string SlotId { get; }
    public bool IsOptimistic { get; }

    public InventoryChangedMessage(InventoryChangeType type, string itemId, string slotId, bool isOptimistic)
    {
        ChangeType = type;
        ItemId = itemId;
        SlotId = slotId;
        IsOptimistic = isOptimistic;
    }
}

public enum InventoryChangeType
{
    ItemEquipped,
    ItemUnequipped,
    ItemAcquired,
    ItemRemoved
}

// Assets/_Core/Events/Messages/AchievementChangedMessage.cs
public readonly struct AchievementChangedMessage : IMessage
{
    public string AchievementId { get; }
    public AchievementChangeType ChangeType { get; }
    public bool IsOptimistic { get; }

    public AchievementChangedMessage(string id, AchievementChangeType type, bool isOptimistic)
    {
        AchievementId = id;
        ChangeType = type;
        IsOptimistic = isOptimistic;
    }
}

public enum AchievementChangeType
{
    ProgressUpdated,
    Unlocked,
    Claimed,
    RolledBack
}

// Assets/_Core/Events/Messages/TaskProgressMessage.cs
public readonly struct TaskProgressMessage : IMessage
{
    public string TaskId { get; }
    public int CurrentProgress { get; }
    public int TargetProgress { get; }
    public bool IsCompleted { get; }
    public bool IsOptimistic { get; }

    public TaskProgressMessage(string taskId, int current, int target, bool completed, bool isOptimistic)
    {
        TaskId = taskId;
        CurrentProgress = current;
        TargetProgress = target;
        IsCompleted = completed;
        IsOptimistic = isOptimistic;
    }
}

// Assets/_Core/Events/Messages/OperationRolledBackMessage.cs
public readonly struct OperationRolledBackMessage : IMessage
{
    public string OperationType { get; }
    public string Reason { get; }
    public bool ShouldNotifyUser { get; }

    public OperationRolledBackMessage(string operationType, string reason, bool shouldNotify)
    {
        OperationType = operationType;
        Reason = reason;
        ShouldNotifyUser = shouldNotify;
    }
}
```

### 2.4 MessageBus Usage Examples

```csharp
// Publisher example
public class GameManager
{
    private readonly IMessageBus _messageBus;

    public GameManager(IMessageBus messageBus)
    {
        _messageBus = messageBus;
    }

    public void SetPhase(GamePhase newPhase)
    {
        var previousPhase = _currentPhase;
        _currentPhase = newPhase;

        _messageBus.Publish(new GamePhaseChangedMessage(previousPhase, newPhase));
    }
}

// Subscriber example (MonoBehaviour)
public class UIMainMenu : MonoBehaviour
{
    [Inject] private IMessageBus _messageBus;

    private IDisposable _subscription;

    void Start()
    {
        _subscription = _messageBus.Subscribe<GamePhaseChangedMessage>(OnPhaseChanged);
    }

    void OnDestroy()
    {
        _subscription?.Dispose();
    }

    private void OnPhaseChanged(GamePhaseChangedMessage msg)
    {
        gameObject.SetActive(msg.NewPhase == GamePhase.Meta);
    }
}

// Multiple subscriptions with CompositeDisposable
public class UIHud : MonoBehaviour
{
    [Inject] private IMessageBus _messageBus;

    private readonly CompositeDisposable _subscriptions = new();

    void Start()
    {
        _subscriptions.Add(_messageBus.Subscribe<CurrencyChangedMessage>(OnCurrencyChanged));
        _subscriptions.Add(_messageBus.Subscribe<TaskProgressMessage>(OnTaskProgress));
        _subscriptions.Add(_messageBus.Subscribe<AchievementChangedMessage>(OnAchievement));
    }

    void OnDestroy()
    {
        _subscriptions.Dispose();
    }
}
```

---

## BÖLÜM 3: OPTIMISTIC OPERATION INFRASTRUCTURE

### 3.1 Core Interfaces

```csharp
// Assets/_Core/Optimistic/Core/ISnapshotable.cs
/// <summary>
/// State'i snapshot alıp restore edebilen interface.
/// </summary>
public interface ISnapshotable<TSnapshot>
{
    /// <summary>
    /// Mevcut state'in immutable kopyasını oluşturur.
    /// </summary>
    TSnapshot CreateSnapshot();

    /// <summary>
    /// Snapshot'tan state'i restore eder.
    /// </summary>
    void RestoreSnapshot(TSnapshot snapshot);
}
```

```csharp
// Assets/_Core/Optimistic/Core/OperationResult.cs
using System;

public enum OperationStatus
{
    Success,
    RolledBack,
    NetworkError,
    ValidationError,
    Cancelled
}

public class OperationResult
{
    public OperationStatus Status { get; }
    public string Message { get; }
    public Exception Exception { get; }
    public bool CanRetry { get; }
    public bool WasOptimistic { get; }

    private OperationResult(OperationStatus status, string message, Exception ex, bool canRetry, bool wasOptimistic)
    {
        Status = status;
        Message = message;
        Exception = ex;
        CanRetry = canRetry;
        WasOptimistic = wasOptimistic;
    }

    public bool IsSuccess => Status == OperationStatus.Success;
    public bool IsFailure => Status != OperationStatus.Success;

    public static OperationResult Success(string message = null)
        => new(OperationStatus.Success, message, null, false, true);

    public static OperationResult RolledBack(string reason)
        => new(OperationStatus.RolledBack, reason, null, false, true);

    public static OperationResult NetworkError(Exception ex, bool canRetry = true)
        => new(OperationStatus.NetworkError, ex.Message, ex, canRetry, true);

    public static OperationResult ValidationError(string message)
        => new(OperationStatus.ValidationError, message, null, false, false);

    public static OperationResult Cancelled()
        => new(OperationStatus.Cancelled, "Operation cancelled", null, false, false);
}

public class OperationResult<T> : OperationResult
{
    public T Data { get; }

    private OperationResult(OperationStatus status, T data, string message, Exception ex, bool canRetry, bool wasOptimistic)
        : base(status, message, ex, canRetry, wasOptimistic)
    {
        Data = data;
    }

    public static OperationResult<T> Success(T data, string message = null)
        => new(OperationStatus.Success, data, message, null, false, true);

    public new static OperationResult<T> RolledBack(string reason)
        => new(OperationStatus.RolledBack, default, reason, null, false, true);

    public new static OperationResult<T> NetworkError(Exception ex, bool canRetry = true)
        => new(OperationStatus.NetworkError, default, ex.Message, ex, canRetry, true);

    public new static OperationResult<T> ValidationError(string message)
        => new(OperationStatus.ValidationError, default, message, null, false, false);
}
```

### 3.2 Optimistic Operation Base

```csharp
// Assets/_Core/Optimistic/Core/OptimisticOperationBase.cs
using System;
using Cysharp.Threading.Tasks;

/// <summary>
/// Optimistic operation'lar için base class.
/// Template Method pattern kullanır.
/// </summary>
public abstract class OptimisticOperationBase<TSnapshot, TResult>
{
    protected readonly IMessageBus _messageBus;
    protected readonly ILogger _logger;

    protected TSnapshot _snapshot;
    protected bool _isRolledBack;

    protected OptimisticOperationBase(IMessageBus messageBus, ILogger logger)
    {
        _messageBus = messageBus;
        _logger = logger;
    }

    /// <summary>
    /// Optimistic operation'ı execute eder.
    /// </summary>
    public async UniTask<OperationResult<TResult>> ExecuteAsync()
    {
        // 1. Validation
        var validationResult = Validate();
        if (!validationResult.IsValid)
        {
            return OperationResult<TResult>.ValidationError(validationResult.ErrorMessage);
        }

        // 2. Snapshot
        _snapshot = CreateSnapshot();

        // 3. Optimistic Update
        try
        {
            ApplyOptimisticUpdate();
        }
        catch (Exception ex)
        {
            _logger.LogError($"Optimistic update failed: {ex}");
            return OperationResult<TResult>.ValidationError("Failed to apply optimistic update");
        }

        // 4. Server Request
        try
        {
            var serverResult = await ExecuteServerOperationAsync();

            if (serverResult.IsSuccess)
            {
                // 5a. Confirm
                ConfirmWithServerData(serverResult.Data);
                return OperationResult<TResult>.Success(serverResult.Data);
            }
            else
            {
                // 5b. Rollback (business error)
                Rollback(serverResult.Message);
                return OperationResult<TResult>.RolledBack(serverResult.Message);
            }
        }
        catch (Exception ex)
        {
            // 5c. Rollback (network error)
            _logger.LogError($"Server operation failed: {ex}");
            Rollback(ex.Message);

            var canRetry = IsRetryableException(ex);
            return OperationResult<TResult>.NetworkError(ex, canRetry);
        }
    }

    /// <summary>
    /// İşlem öncesi validation. Override edilebilir.
    /// </summary>
    protected virtual ValidationResult Validate() => ValidationResult.Valid();

    /// <summary>
    /// Snapshot oluşturur. Subclass implement etmeli.
    /// </summary>
    protected abstract TSnapshot CreateSnapshot();

    /// <summary>
    /// Optimistic update uygular. Subclass implement etmeli.
    /// </summary>
    protected abstract void ApplyOptimisticUpdate();

    /// <summary>
    /// Server operation'ı execute eder. Subclass implement etmeli.
    /// </summary>
    protected abstract UniTask<ServerResult<TResult>> ExecuteServerOperationAsync();

    /// <summary>
    /// Server response ile state'i confirm eder. Override edilebilir.
    /// </summary>
    protected virtual void ConfirmWithServerData(TResult serverData) { }

    /// <summary>
    /// Rollback uygular. Subclass implement etmeli.
    /// </summary>
    protected abstract void RestoreFromSnapshot(TSnapshot snapshot);

    /// <summary>
    /// Rollback işlemini yapar ve event publish eder.
    /// </summary>
    protected void Rollback(string reason)
    {
        if (_isRolledBack) return;
        _isRolledBack = true;

        RestoreFromSnapshot(_snapshot);

        _messageBus.Publish(new OperationRolledBackMessage(
            GetType().Name,
            reason,
            ShouldNotifyUserOnRollback()
        ));
    }

    /// <summary>
    /// Rollback'te kullanıcı bilgilendirilmeli mi?
    /// </summary>
    protected virtual bool ShouldNotifyUserOnRollback() => true;

    /// <summary>
    /// Exception retry edilebilir mi?
    /// </summary>
    protected virtual bool IsRetryableException(Exception ex)
    {
        return ex is TimeoutException ||
               ex is System.Net.WebException ||
               (ex.Message?.Contains("network") ?? false);
    }

    protected struct ValidationResult
    {
        public bool IsValid { get; }
        public string ErrorMessage { get; }

        private ValidationResult(bool isValid, string errorMessage)
        {
            IsValid = isValid;
            ErrorMessage = errorMessage;
        }

        public static ValidationResult Valid() => new(true, null);
        public static ValidationResult Invalid(string message) => new(false, message);
    }

    protected struct ServerResult<T>
    {
        public bool IsSuccess { get; }
        public T Data { get; }
        public string Message { get; }

        private ServerResult(bool success, T data, string message)
        {
            IsSuccess = success;
            Data = data;
            Message = message;
        }

        public static ServerResult<T> Success(T data) => new(true, data, null);
        public static ServerResult<T> Failure(string message) => new(false, default, message);
    }
}
```

### 3.3 Concrete Operation Example

```csharp
// Example: EquipItemOperation.cs
public class EquipItemOperation : OptimisticOperationBase<InventorySnapshot, EquipItemResponse>
{
    private readonly IInventoryState _inventoryState;
    private readonly IInventoryRemoteService _remoteService;
    private readonly string _itemId;
    private readonly string _slotId;

    public EquipItemOperation(
        string itemId,
        string slotId,
        IInventoryState inventoryState,
        IInventoryRemoteService remoteService,
        IMessageBus messageBus,
        ILogger logger)
        : base(messageBus, logger)
    {
        _itemId = itemId;
        _slotId = slotId;
        _inventoryState = inventoryState;
        _remoteService = remoteService;
    }

    protected override ValidationResult Validate()
    {
        if (!_inventoryState.HasItem(_itemId))
            return ValidationResult.Invalid("Item not in inventory");

        if (_inventoryState.IsEquipped(_itemId))
            return ValidationResult.Invalid("Item already equipped");

        return ValidationResult.Valid();
    }

    protected override InventorySnapshot CreateSnapshot()
    {
        return _inventoryState.CreateSnapshot();
    }

    protected override void ApplyOptimisticUpdate()
    {
        _inventoryState.EquipItem(_itemId, _slotId);

        _messageBus.Publish(new InventoryChangedMessage(
            InventoryChangeType.ItemEquipped,
            _itemId,
            _slotId,
            isOptimistic: true
        ));
    }

    protected override async UniTask<ServerResult<EquipItemResponse>> ExecuteServerOperationAsync()
    {
        var response = await _remoteService.EquipItemAsync(_itemId, _slotId);

        if (response.Success)
            return ServerResult<EquipItemResponse>.Success(response);
        else
            return ServerResult<EquipItemResponse>.Failure(response.ErrorMessage);
    }

    protected override void ConfirmWithServerData(EquipItemResponse serverData)
    {
        // Server'dan gelen timestamp veya ek veri ile sync et
        _inventoryState.SyncEquipmentTimestamp(_itemId, serverData.EquippedAt);

        _messageBus.Publish(new InventoryChangedMessage(
            InventoryChangeType.ItemEquipped,
            _itemId,
            _slotId,
            isOptimistic: false // Artık confirmed
        ));
    }

    protected override void RestoreFromSnapshot(InventorySnapshot snapshot)
    {
        _inventoryState.RestoreSnapshot(snapshot);

        _messageBus.Publish(new InventoryChangedMessage(
            InventoryChangeType.ItemUnequipped, // Rollback = unequip
            _itemId,
            _slotId,
            isOptimistic: false
        ));
    }
}
```

---

## BÖLÜM 4: CORE INTERFACES

### 4.1 Service Interfaces

```csharp
// Assets/_Core/Interfaces/Services/ICurrencyService.cs
public interface ICurrencyService : ISnapshotable<CurrencySnapshot>
{
    int GetBalance(CurrencyType type);
    bool CanAfford(CurrencyType type, int amount);

    /// <summary>
    /// Optimistic olarak currency ekler.
    /// </summary>
    UniTask<OperationResult> AddCurrencyOptimisticAsync(CurrencyType type, int amount, string source);

    /// <summary>
    /// Optimistic olarak currency harcar.
    /// </summary>
    UniTask<OperationResult> SpendCurrencyOptimisticAsync(CurrencyType type, int amount, string reason);

    /// <summary>
    /// Server ile sync eder.
    /// </summary>
    UniTask SyncWithServerAsync();

    event Action<CurrencyChangedMessage> OnCurrencyChanged;
}

// Assets/_Core/Interfaces/Services/IInventoryService.cs
public interface IInventoryService : ISnapshotable<InventorySnapshot>
{
    bool HasItem(string itemId);
    bool IsEquipped(string itemId);
    IReadOnlyList<string> GetEquippedItems(string slotId);
    IReadOnlyList<InventoryItem> GetAllItems();

    UniTask<OperationResult> EquipItemOptimisticAsync(string itemId, string slotId);
    UniTask<OperationResult> UnequipItemOptimisticAsync(string itemId);
    UniTask<OperationResult<InventoryItem>> AcquireItemOptimisticAsync(string itemId, string source);

    UniTask SyncWithServerAsync();

    event Action<InventoryChangedMessage> OnInventoryChanged;
}

// Assets/_Core/Interfaces/Services/IAchievementService.cs
public interface IAchievementService
{
    IReadOnlyList<Achievement> GetAllAchievements();
    Achievement GetAchievement(string achievementId);
    bool IsUnlocked(string achievementId);
    bool IsClaimed(string achievementId);

    UniTask<OperationResult> ClaimAchievementOptimisticAsync(string achievementId);
    void UpdateProgressOptimistic(string achievementId, int progress);

    UniTask SyncWithServerAsync();

    event Action<AchievementChangedMessage> OnAchievementChanged;
}

// Assets/_Core/Interfaces/Services/ITaskService.cs
public interface ITaskService
{
    IReadOnlyList<GameTask> GetActiveTasks();
    IReadOnlyList<GameTask> GetCompletedTasks();
    GameTask GetTask(string taskId);

    void AddProgressOptimistic(string taskId, int amount);
    UniTask<OperationResult> ClaimTaskRewardOptimisticAsync(string taskId);

    UniTask SyncWithServerAsync();

    event Action<TaskProgressMessage> OnTaskProgressChanged;
}

// Assets/_Core/Interfaces/Services/IEnergyService.cs
public interface IEnergyService
{
    int CurrentEnergy { get; }
    int MaxEnergy { get; }
    DateTime NextRegenTime { get; }
    bool HasEnoughEnergy(int amount);

    UniTask<OperationResult> ConsumeEnergyOptimisticAsync(int amount);
    UniTask<OperationResult> RefillEnergyOptimisticAsync();
    UniTask<EnergySnapshot> FetchSnapshotAsync();

    event Action<int, int> OnEnergyChanged; // current, max
}

// Assets/_Core/Interfaces/Services/ISessionService.cs
public interface ISessionService
{
    bool IsSessionActive { get; }
    string CurrentSessionId { get; }
    SessionState CurrentState { get; }

    UniTask<OperationResult<SessionInfo>> RequestSessionAsync(GameMode mode);
    UniTask<OperationResult<SessionResult>> SubmitSessionAsync(SessionData data);
    void CancelSession();

    event Action<SessionState> OnSessionStateChanged;
}

// Assets/_Core/Interfaces/Services/ILeaderboardService.cs
public interface ILeaderboardService
{
    UniTask<IReadOnlyList<LeaderboardEntry>> GetTopEntriesAsync(int count);
    UniTask<IReadOnlyList<LeaderboardEntry>> GetNearbyEntriesAsync(string userId, int range);
    UniTask<LeaderboardEntry> GetUserEntryAsync(string userId);

    UniTask<OperationResult> SubmitScoreOptimisticAsync(int score);

    event Action OnLeaderboardUpdated;
}
```

### 4.2 UI Interfaces

```csharp
// Assets/_Core/Interfaces/UI/INavigationService.cs
public interface INavigationService
{
    UIScreen CurrentScreen { get; }
    bool CanGoBack { get; }

    UniTask PushScreenAsync<T>(object parameters = null) where T : UIScreen;
    UniTask PopScreenAsync();
    UniTask PopToRootAsync();
    UniTask ReplaceScreenAsync<T>(object parameters = null) where T : UIScreen;

    UniTask<T> ShowPopupAsync<T>(object parameters = null) where T : UIPopup;
    UniTask HidePopupAsync<T>() where T : UIPopup;
    UniTask HideAllPopupsAsync();

    event Action<UIScreen> OnScreenChanged;
}

// Assets/_Core/Interfaces/UI/IFeedbackService.cs
public interface IFeedbackService
{
    void ShowToast(string message, ToastType type = ToastType.Info);
    void ShowSuccessToast(string message);
    void ShowErrorToast(string message);

    void PlayHaptic(HapticType type);
    void PlaySuccessHaptic();
    void PlayErrorHaptic();

    UniTask ShowConfirmationDialogAsync(string title, string message, string confirmText, string cancelText);
    UniTask ShowRetryDialogAsync(string message, Func<UniTask> onRetry);
}

// Assets/_Core/Interfaces/UI/IDialogService.cs
public interface IDialogService
{
    UniTask<bool> ShowConfirmAsync(string title, string message);
    UniTask<string> ShowInputAsync(string title, string placeholder);
    UniTask ShowAlertAsync(string title, string message);
    UniTask<int> ShowOptionsAsync(string title, params string[] options);
}
```

---

## BÖLÜM 5: MIGRATION CHECKLIST

### 5.1 Step-by-Step Migration

**Week 1: Setup**
- [ ] VContainer package kurulumu
- [ ] UniTask package kurulumu (yoksa)
- [ ] `_Core` folder structure oluşturma
- [ ] `RootLifetimeScope` ve `GameSceneLifetimeScope` oluşturma
- [ ] Boot Scene'e `RootLifetimeScope` ekleme
- [ ] Game Scene'e `GameSceneLifetimeScope` ekleme

**Week 2: MessageBus**
- [ ] `IMessageBus` ve `MessageBus` implementasyonu
- [ ] Common message types oluşturma
- [ ] `CompositeDisposable` helper oluşturma
- [ ] Mevcut 1-2 event'i MessageBus'a migrate etme (test amaçlı)

**Week 3: Optimistic Infrastructure**
- [ ] `ISnapshotable<T>` interface
- [ ] `OperationResult` ve `OperationResult<T>` classes
- [ ] `OptimisticOperationBase<TSnapshot, TResult>` abstract class
- [ ] Örnek operation implementasyonu (EquipItem)

**Week 4: Core Interfaces**
- [ ] Tüm service interface'lerini tanımlama
- [ ] UI interface'lerini tanımlama
- [ ] Interface documentation

### 5.2 Verification Checklist

Her step sonrası:
- [ ] Proje compile ediyor
- [ ] Mevcut özellikler çalışıyor (regression yok)
- [ ] Yeni kod unit test'e uygun
- [ ] Git commit yapıldı

---

## BÖLÜM 6: FILE INVENTORY

Bu fazda oluşturulacak dosyalar:

```
Assets/_Core/
├── DI/
│   ├── Installers/
│   │   ├── RootLifetimeScope.cs           [YENİ]
│   │   ├── GameSceneLifetimeScope.cs      [YENİ]
│   │   └── BootSceneLifetimeScope.cs      [YENİ]
│   └── Extensions/
│       └── VContainerExtensions.cs        [YENİ]
│
├── Events/
│   ├── Core/
│   │   ├── IMessage.cs                    [YENİ]
│   │   ├── IMessageBus.cs                 [YENİ]
│   │   └── MessageBus.cs                  [YENİ]
│   ├── Messages/
│   │   ├── GamePhaseChangedMessage.cs     [YENİ]
│   │   ├── CurrencyChangedMessage.cs      [YENİ]
│   │   ├── InventoryChangedMessage.cs     [YENİ]
│   │   ├── AchievementChangedMessage.cs   [YENİ]
│   │   ├── TaskProgressMessage.cs         [YENİ]
│   │   └── OperationRolledBackMessage.cs  [YENİ]
│   └── CompositeDisposable.cs             [YENİ]
│
├── Optimistic/
│   ├── Core/
│   │   ├── ISnapshotable.cs               [YENİ]
│   │   ├── OperationResult.cs             [YENİ]
│   │   └── OptimisticOperationBase.cs     [YENİ]
│   └── Strategies/
│       ├── IRollbackStrategy.cs           [YENİ]
│       └── IFallbackStrategy.cs           [YENİ]
│
└── Interfaces/
    ├── Services/
    │   ├── ICurrencyService.cs            [YENİ]
    │   ├── IInventoryService.cs           [YENİ]
    │   ├── IAchievementService.cs         [YENİ]
    │   ├── ITaskService.cs                [YENİ]
    │   ├── ISessionService.cs             [YENİ]
    │   ├── IEnergyService.cs              [YENİ]
    │   ├── ILeaderboardService.cs         [YENİ]
    │   └── IAuthService.cs                [YENİ]
    └── UI/
        ├── INavigationService.cs          [YENİ]
        ├── IFeedbackService.cs            [YENİ]
        └── IDialogService.cs              [YENİ]
```

**Toplam:** ~25 yeni dosya

---

## SONRAKI ADIMLAR

Bu faz tamamlandığında:
1. DI container tüm service'leri inject edebilir durumda
2. MessageBus event publish/subscribe yapabiliyor
3. Optimistic operation infrastructure hazır
4. Interface'ler tanımlı (implementation Phase 2'de)

**Sonraki döküman:** [01.2_PHASE_TWO_SERVICE_LAYER.md](01.2_PHASE_TWO_SERVICE_LAYER.md)

---

*Bu döküman Phase 1 Infrastructure v1.0'dır.*
