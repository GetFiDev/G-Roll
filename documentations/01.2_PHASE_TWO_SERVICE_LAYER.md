# Phase 2: Service Layer Implementation

**Referans:** [01_ARCHITECTURE_ANALYSIS_REPORT.md](01_ARCHITECTURE_ANALYSIS_REPORT.md)
**Önkoşul:** [01.1_PHASE_ONE_INFRASTRUCTURE.md](01.1_PHASE_ONE_INFRASTRUCTURE.md)
**Felsefe:** [00_OPTIMISTIC_CLIENT_ARCHITECTURE.md](00_OPTIMISTIC_CLIENT_ARCHITECTURE.md)
**Versiyon:** 1.0

---

## EXECUTIVE SUMMARY

Bu döküman, Phase 1'de tanımlanan interface'lerin **concrete implementation**'larını tanımlar. Her service:

1. **Optimistic Architecture** prensiplerini uygular
2. **Firebase backend** ile entegre çalışır
3. **Snapshot/Rollback** mekanizmalarını içerir
4. **MessageBus** üzerinden event yayınlar

---

## PRE-FLIGHT CHECKLIST

Bu faza başlamadan önce:

- [ ] Phase 1 tamamlanmış olmalı
- [ ] VContainer çalışır durumda
- [ ] MessageBus çalışır durumda
- [ ] Tüm interface'ler tanımlı
- [ ] Branch: `refactor/phase-2-services`

---

## BÖLÜM 1: SERVICE ARCHITECTURE OVERVIEW

### 1.1 Service Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           UI LAYER                                       │
│   ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐                      │
│   │ Screens │ │ Popups  │ │  HUD    │ │Components│                      │
│   └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘                      │
│        │           │           │           │                             │
│        └───────────┴───────────┴───────────┘                             │
│                         │                                                │
│                    [MessageBus]                                          │
│                         │                                                │
├─────────────────────────┼───────────────────────────────────────────────┤
│                         │        SERVICE LAYER                           │
│   ┌─────────────────────┼─────────────────────────────────┐             │
│   │                     ▼                                  │             │
│   │  ┌──────────────────────────────────────────────────┐ │             │
│   │  │              Optimistic Services                  │ │             │
│   │  │  ┌──────────┐ ┌──────────┐ ┌──────────────────┐  │ │             │
│   │  │  │ Currency │ │Inventory │ │   Achievement    │  │ │             │
│   │  │  │ Service  │ │ Service  │ │    Service       │  │ │             │
│   │  │  └────┬─────┘ └────┬─────┘ └────────┬─────────┘  │ │             │
│   │  │       │            │                │            │ │             │
│   │  │  ┌────┴────┐  ┌────┴────┐    ┌──────┴──────┐    │ │             │
│   │  │  │ Task    │  │ Energy  │    │ Leaderboard │    │ │             │
│   │  │  │ Service │  │ Service │    │   Service   │    │ │             │
│   │  │  └────┬────┘  └────┬────┘    └──────┬──────┘    │ │             │
│   │  │       │            │                │            │ │             │
│   │  └───────┼────────────┼────────────────┼────────────┘ │             │
│   │          │            │                │              │             │
│   │          └────────────┼────────────────┘              │             │
│   │                       │                               │             │
│   │               ┌───────▼───────┐                       │             │
│   │               │ Session Service│                      │             │
│   │               └───────┬───────┘                       │             │
│   └───────────────────────┼───────────────────────────────┘             │
│                           │                                              │
├───────────────────────────┼─────────────────────────────────────────────┤
│                           │     REMOTE SERVICE LAYER                     │
│   ┌───────────────────────┼───────────────────────────────┐             │
│   │                       ▼                                │             │
│   │  ┌─────────────────────────────────────────────────┐  │             │
│   │  │            Firebase Gateway                      │  │             │
│   │  │  ┌──────────┐ ┌──────────┐ ┌──────────────────┐ │  │             │
│   │  │  │   Auth   │ │Firestore │ │     Functions    │ │  │             │
│   │  │  └──────────┘ └──────────┘ └──────────────────┘ │  │             │
│   │  └─────────────────────────────────────────────────┘  │             │
│   └───────────────────────────────────────────────────────┘             │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 Service Responsibilities Matrix

| Service | Optimistic | Snapshot | Batch | Sync Strategy |
|---------|------------|----------|-------|---------------|
| CurrencyService | Yes | Full | No | Immediate |
| InventoryService | Yes | Full | No | Immediate |
| AchievementService | Yes | Partial | No | Immediate |
| TaskService | Yes | Partial | Yes (2s) | Batched |
| EnergyService | Yes | Full | No | Immediate |
| SessionService | No* | N/A | No | Immediate |
| LeaderboardService | Yes | Score only | No | Event-Driven |

*SessionService critical olduğundan pessimistic kalır

---

## BÖLÜM 2: CURRENCY SERVICE

### 2.1 State Model

```csharp
// Assets/Domain/Economy/Models/CurrencyState.cs
using System;
using System.Collections.Generic;

public class CurrencyState
{
    private readonly Dictionary<CurrencyType, int> _balances = new();

    public int GetBalance(CurrencyType type)
    {
        return _balances.TryGetValue(type, out var balance) ? balance : 0;
    }

    public void SetBalance(CurrencyType type, int amount)
    {
        if (amount < 0) throw new ArgumentException("Balance cannot be negative");
        _balances[type] = amount;
    }

    public void Add(CurrencyType type, int amount)
    {
        if (amount < 0) throw new ArgumentException("Amount cannot be negative");
        _balances[type] = GetBalance(type) + amount;
    }

    public bool TrySpend(CurrencyType type, int amount)
    {
        if (amount < 0) throw new ArgumentException("Amount cannot be negative");

        var current = GetBalance(type);
        if (current < amount) return false;

        _balances[type] = current - amount;
        return true;
    }

    public bool CanAfford(CurrencyType type, int amount)
    {
        return GetBalance(type) >= amount;
    }
}

public enum CurrencyType
{
    Coin,
    Gem,
    Token
}
```

### 2.2 Snapshot

```csharp
// Assets/Domain/Economy/Models/CurrencySnapshot.cs
using System;
using System.Collections.Generic;

public readonly struct CurrencySnapshot
{
    public IReadOnlyDictionary<CurrencyType, int> Balances { get; }
    public DateTime Timestamp { get; }

    public CurrencySnapshot(Dictionary<CurrencyType, int> balances)
    {
        // Deep copy
        Balances = new Dictionary<CurrencyType, int>(balances);
        Timestamp = DateTime.UtcNow;
    }

    public int GetBalance(CurrencyType type)
    {
        return Balances.TryGetValue(type, out var balance) ? balance : 0;
    }
}
```

### 2.3 Service Implementation

```csharp
// Assets/Domain/Economy/CurrencyService.cs
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using VContainer;

public class CurrencyService : ICurrencyService
{
    private readonly CurrencyState _state;
    private readonly ICurrencyRemoteService _remoteService;
    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    private CurrencySnapshot _lastSnapshot;
    private bool _hasPendingOperation;

    [Inject]
    public CurrencyService(
        ICurrencyRemoteService remoteService,
        IMessageBus messageBus,
        ILogger logger)
    {
        _state = new CurrencyState();
        _remoteService = remoteService;
        _messageBus = messageBus;
        _logger = logger;
    }

    // ═══════════════════════════════════════════════════════════════
    // ISnapshotable<CurrencySnapshot> Implementation
    // ═══════════════════════════════════════════════════════════════

    public CurrencySnapshot CreateSnapshot()
    {
        var balances = new Dictionary<CurrencyType, int>();
        foreach (CurrencyType type in Enum.GetValues(typeof(CurrencyType)))
        {
            balances[type] = _state.GetBalance(type);
        }
        return new CurrencySnapshot(balances);
    }

    public void RestoreSnapshot(CurrencySnapshot snapshot)
    {
        foreach (var kvp in snapshot.Balances)
        {
            var previousBalance = _state.GetBalance(kvp.Key);
            _state.SetBalance(kvp.Key, kvp.Value);

            // Rollback event
            if (previousBalance != kvp.Value)
            {
                PublishChange(kvp.Key, previousBalance, kvp.Value, isOptimistic: false);
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // ICurrencyService Implementation
    // ═══════════════════════════════════════════════════════════════

    public int GetBalance(CurrencyType type) => _state.GetBalance(type);

    public bool CanAfford(CurrencyType type, int amount) => _state.CanAfford(type, amount);

    public event Action<CurrencyChangedMessage> OnCurrencyChanged;

    public async UniTask<OperationResult> AddCurrencyOptimisticAsync(
        CurrencyType type,
        int amount,
        string source)
    {
        if (amount <= 0)
            return OperationResult.ValidationError("Amount must be positive");

        if (_hasPendingOperation)
            return OperationResult.ValidationError("Another operation is pending");

        _hasPendingOperation = true;

        // 1. SNAPSHOT
        _lastSnapshot = CreateSnapshot();
        var previousBalance = _state.GetBalance(type);

        // 2. OPTIMISTIC UPDATE
        _state.Add(type, amount);
        var newBalance = _state.GetBalance(type);
        PublishChange(type, previousBalance, newBalance, isOptimistic: true);

        _logger.Log($"[Currency] Optimistic add: {type} +{amount} (source: {source})");

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.AddCurrencyAsync(type, amount, source);

            if (response.Success)
            {
                // 4a. CONFIRM - Sync with server balance
                if (response.NewBalance != newBalance)
                {
                    _logger.LogWarning($"[Currency] Balance mismatch. Client: {newBalance}, Server: {response.NewBalance}");
                    _state.SetBalance(type, response.NewBalance);
                    PublishChange(type, newBalance, response.NewBalance, isOptimistic: false);
                }

                _hasPendingOperation = false;
                return OperationResult.Success();
            }
            else
            {
                // 4b. ROLLBACK - Business error
                RestoreSnapshot(_lastSnapshot);
                _hasPendingOperation = false;
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            // 4c. ROLLBACK - Network error
            _logger.LogError($"[Currency] Network error: {ex.Message}");
            RestoreSnapshot(_lastSnapshot);
            _hasPendingOperation = false;
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask<OperationResult> SpendCurrencyOptimisticAsync(
        CurrencyType type,
        int amount,
        string reason)
    {
        if (amount <= 0)
            return OperationResult.ValidationError("Amount must be positive");

        if (!_state.CanAfford(type, amount))
            return OperationResult.ValidationError($"Insufficient {type}");

        if (_hasPendingOperation)
            return OperationResult.ValidationError("Another operation is pending");

        _hasPendingOperation = true;

        // 1. SNAPSHOT
        _lastSnapshot = CreateSnapshot();
        var previousBalance = _state.GetBalance(type);

        // 2. OPTIMISTIC UPDATE
        _state.TrySpend(type, amount);
        var newBalance = _state.GetBalance(type);
        PublishChange(type, previousBalance, newBalance, isOptimistic: true);

        _logger.Log($"[Currency] Optimistic spend: {type} -{amount} (reason: {reason})");

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.SpendCurrencyAsync(type, amount, reason);

            if (response.Success)
            {
                // 4a. CONFIRM
                if (response.NewBalance != newBalance)
                {
                    _state.SetBalance(type, response.NewBalance);
                    PublishChange(type, newBalance, response.NewBalance, isOptimistic: false);
                }

                _hasPendingOperation = false;
                return OperationResult.Success();
            }
            else
            {
                // 4b. ROLLBACK
                RestoreSnapshot(_lastSnapshot);
                _hasPendingOperation = false;
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            // 4c. ROLLBACK
            _logger.LogError($"[Currency] Network error: {ex.Message}");
            RestoreSnapshot(_lastSnapshot);
            _hasPendingOperation = false;
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask SyncWithServerAsync()
    {
        try
        {
            var serverState = await _remoteService.FetchBalancesAsync();

            foreach (var kvp in serverState.Balances)
            {
                var localBalance = _state.GetBalance(kvp.Key);
                if (localBalance != kvp.Value)
                {
                    _state.SetBalance(kvp.Key, kvp.Value);
                    PublishChange(kvp.Key, localBalance, kvp.Value, isOptimistic: false);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Currency] Sync failed: {ex.Message}");
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Private Helpers
    // ═══════════════════════════════════════════════════════════════

    private void PublishChange(CurrencyType type, int previous, int newAmount, bool isOptimistic)
    {
        var message = new CurrencyChangedMessage(type, previous, newAmount, isOptimistic);
        OnCurrencyChanged?.Invoke(message);
        _messageBus.Publish(message);
    }
}
```

### 2.4 Remote Service Interface

```csharp
// Assets/Infrastructure/Firebase/ICurrencyRemoteService.cs
public interface ICurrencyRemoteService
{
    UniTask<CurrencyOperationResponse> AddCurrencyAsync(CurrencyType type, int amount, string source);
    UniTask<CurrencyOperationResponse> SpendCurrencyAsync(CurrencyType type, int amount, string reason);
    UniTask<CurrencyBalancesResponse> FetchBalancesAsync();
}

public struct CurrencyOperationResponse
{
    public bool Success { get; set; }
    public int NewBalance { get; set; }
    public string ErrorMessage { get; set; }
}

public struct CurrencyBalancesResponse
{
    public Dictionary<CurrencyType, int> Balances { get; set; }
}
```

---

## BÖLÜM 3: INVENTORY SERVICE

### 3.1 State Model

```csharp
// Assets/Domain/Economy/Models/InventoryState.cs
using System;
using System.Collections.Generic;
using System.Linq;

public class InventoryState
{
    private readonly Dictionary<string, InventoryItem> _items = new();
    private readonly Dictionary<string, string> _equippedSlots = new(); // slotId -> itemId

    public bool HasItem(string itemId) => _items.ContainsKey(itemId);

    public bool IsEquipped(string itemId)
    {
        return _equippedSlots.ContainsValue(itemId);
    }

    public string GetEquippedItem(string slotId)
    {
        return _equippedSlots.TryGetValue(slotId, out var itemId) ? itemId : null;
    }

    public IReadOnlyList<string> GetEquippedItemIds()
    {
        return _equippedSlots.Values.ToList();
    }

    public IReadOnlyList<InventoryItem> GetAllItems()
    {
        return _items.Values.ToList();
    }

    public void AddItem(InventoryItem item)
    {
        _items[item.Id] = item;
    }

    public void RemoveItem(string itemId)
    {
        _items.Remove(itemId);

        // Unequip if equipped
        var slotToRemove = _equippedSlots.FirstOrDefault(x => x.Value == itemId).Key;
        if (slotToRemove != null)
        {
            _equippedSlots.Remove(slotToRemove);
        }
    }

    public void EquipItem(string itemId, string slotId)
    {
        if (!_items.ContainsKey(itemId))
            throw new InvalidOperationException($"Item {itemId} not in inventory");

        _equippedSlots[slotId] = itemId;
    }

    public void UnequipItem(string slotId)
    {
        _equippedSlots.Remove(slotId);
    }

    public void UnequipByItemId(string itemId)
    {
        var slot = _equippedSlots.FirstOrDefault(x => x.Value == itemId).Key;
        if (slot != null)
        {
            _equippedSlots.Remove(slot);
        }
    }

    // For snapshot restore
    public void SetEquippedSlots(Dictionary<string, string> slots)
    {
        _equippedSlots.Clear();
        foreach (var kvp in slots)
        {
            _equippedSlots[kvp.Key] = kvp.Value;
        }
    }

    public void SetItems(Dictionary<string, InventoryItem> items)
    {
        _items.Clear();
        foreach (var kvp in items)
        {
            _items[kvp.Key] = kvp.Value;
        }
    }

    public Dictionary<string, string> GetEquippedSlotsCopy()
    {
        return new Dictionary<string, string>(_equippedSlots);
    }

    public Dictionary<string, InventoryItem> GetItemsCopy()
    {
        return new Dictionary<string, InventoryItem>(_items);
    }
}

public class InventoryItem
{
    public string Id { get; set; }
    public string Type { get; set; }
    public string SlotType { get; set; }
    public DateTime AcquiredAt { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}
```

### 3.2 Snapshot

```csharp
// Assets/Domain/Economy/Models/InventorySnapshot.cs
public readonly struct InventorySnapshot
{
    public IReadOnlyDictionary<string, InventoryItem> Items { get; }
    public IReadOnlyDictionary<string, string> EquippedSlots { get; }
    public DateTime Timestamp { get; }

    public InventorySnapshot(
        Dictionary<string, InventoryItem> items,
        Dictionary<string, string> equippedSlots)
    {
        Items = new Dictionary<string, InventoryItem>(items);
        EquippedSlots = new Dictionary<string, string>(equippedSlots);
        Timestamp = DateTime.UtcNow;
    }
}
```

### 3.3 Service Implementation

```csharp
// Assets/Domain/Economy/InventoryService.cs
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using VContainer;

public class InventoryService : IInventoryService
{
    private readonly InventoryState _state;
    private readonly IInventoryRemoteService _remoteService;
    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    [Inject]
    public InventoryService(
        IInventoryRemoteService remoteService,
        IMessageBus messageBus,
        ILogger logger)
    {
        _state = new InventoryState();
        _remoteService = remoteService;
        _messageBus = messageBus;
        _logger = logger;
    }

    // ═══════════════════════════════════════════════════════════════
    // ISnapshotable Implementation
    // ═══════════════════════════════════════════════════════════════

    public InventorySnapshot CreateSnapshot()
    {
        return new InventorySnapshot(
            _state.GetItemsCopy(),
            _state.GetEquippedSlotsCopy()
        );
    }

    public void RestoreSnapshot(InventorySnapshot snapshot)
    {
        _state.SetItems(new Dictionary<string, InventoryItem>(
            (Dictionary<string, InventoryItem>)snapshot.Items));
        _state.SetEquippedSlots(new Dictionary<string, string>(
            (Dictionary<string, string>)snapshot.EquippedSlots));
    }

    // ═══════════════════════════════════════════════════════════════
    // IInventoryService Implementation
    // ═══════════════════════════════════════════════════════════════

    public bool HasItem(string itemId) => _state.HasItem(itemId);
    public bool IsEquipped(string itemId) => _state.IsEquipped(itemId);

    public IReadOnlyList<string> GetEquippedItems(string slotId)
    {
        var item = _state.GetEquippedItem(slotId);
        return item != null ? new List<string> { item } : new List<string>();
    }

    public IReadOnlyList<InventoryItem> GetAllItems() => _state.GetAllItems();

    public event Action<InventoryChangedMessage> OnInventoryChanged;

    public async UniTask<OperationResult> EquipItemOptimisticAsync(string itemId, string slotId)
    {
        // Validation
        if (!_state.HasItem(itemId))
            return OperationResult.ValidationError("Item not in inventory");

        if (_state.IsEquipped(itemId))
            return OperationResult.ValidationError("Item already equipped");

        // 1. SNAPSHOT
        var snapshot = CreateSnapshot();
        var previousEquipped = _state.GetEquippedItem(slotId);

        // 2. OPTIMISTIC UPDATE
        _state.EquipItem(itemId, slotId);
        PublishChange(InventoryChangeType.ItemEquipped, itemId, slotId, true);

        _logger.Log($"[Inventory] Optimistic equip: {itemId} in slot {slotId}");

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.EquipItemAsync(itemId, slotId);

            if (response.Success)
            {
                // 4a. CONFIRM
                PublishChange(InventoryChangeType.ItemEquipped, itemId, slotId, false);
                return OperationResult.Success();
            }
            else
            {
                // 4b. ROLLBACK
                RestoreSnapshot(snapshot);
                PublishChange(InventoryChangeType.ItemUnequipped, itemId, slotId, false);
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            // 4c. ROLLBACK
            _logger.LogError($"[Inventory] Network error: {ex.Message}");
            RestoreSnapshot(snapshot);
            PublishChange(InventoryChangeType.ItemUnequipped, itemId, slotId, false);
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask<OperationResult> UnequipItemOptimisticAsync(string itemId)
    {
        if (!_state.IsEquipped(itemId))
            return OperationResult.ValidationError("Item not equipped");

        // Find the slot
        var slots = _state.GetEquippedSlotsCopy();
        var slotId = "";
        foreach (var kvp in slots)
        {
            if (kvp.Value == itemId)
            {
                slotId = kvp.Key;
                break;
            }
        }

        // 1. SNAPSHOT
        var snapshot = CreateSnapshot();

        // 2. OPTIMISTIC UPDATE
        _state.UnequipByItemId(itemId);
        PublishChange(InventoryChangeType.ItemUnequipped, itemId, slotId, true);

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.UnequipItemAsync(itemId);

            if (response.Success)
            {
                PublishChange(InventoryChangeType.ItemUnequipped, itemId, slotId, false);
                return OperationResult.Success();
            }
            else
            {
                RestoreSnapshot(snapshot);
                PublishChange(InventoryChangeType.ItemEquipped, itemId, slotId, false);
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Inventory] Network error: {ex.Message}");
            RestoreSnapshot(snapshot);
            PublishChange(InventoryChangeType.ItemEquipped, itemId, slotId, false);
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask<OperationResult<InventoryItem>> AcquireItemOptimisticAsync(
        string itemId,
        string source)
    {
        if (_state.HasItem(itemId))
            return OperationResult<InventoryItem>.ValidationError("Item already owned");

        // 1. SNAPSHOT
        var snapshot = CreateSnapshot();

        // 2. OPTIMISTIC UPDATE - Create temporary item
        var tempItem = new InventoryItem
        {
            Id = itemId,
            AcquiredAt = DateTime.UtcNow,
            Metadata = new Dictionary<string, object> { { "source", source } }
        };
        _state.AddItem(tempItem);
        PublishChange(InventoryChangeType.ItemAcquired, itemId, null, true);

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.AcquireItemAsync(itemId, source);

            if (response.Success)
            {
                // Update with actual server data
                _state.RemoveItem(itemId);
                _state.AddItem(response.Item);
                PublishChange(InventoryChangeType.ItemAcquired, itemId, null, false);
                return OperationResult<InventoryItem>.Success(response.Item);
            }
            else
            {
                RestoreSnapshot(snapshot);
                PublishChange(InventoryChangeType.ItemRemoved, itemId, null, false);
                return OperationResult<InventoryItem>.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Inventory] Network error: {ex.Message}");
            RestoreSnapshot(snapshot);
            PublishChange(InventoryChangeType.ItemRemoved, itemId, null, false);
            return OperationResult<InventoryItem>.NetworkError(ex);
        }
    }

    public async UniTask SyncWithServerAsync()
    {
        try
        {
            var serverState = await _remoteService.FetchInventoryAsync();
            _state.SetItems(serverState.Items);
            _state.SetEquippedSlots(serverState.EquippedSlots);

            _messageBus.Publish(new InventorySyncedMessage());
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Inventory] Sync failed: {ex.Message}");
        }
    }

    private void PublishChange(InventoryChangeType type, string itemId, string slotId, bool isOptimistic)
    {
        var message = new InventoryChangedMessage(type, itemId, slotId, isOptimistic);
        OnInventoryChanged?.Invoke(message);
        _messageBus.Publish(message);
    }
}
```

---

## BÖLÜM 4: TASK SERVICE (Batched Updates)

### 4.1 State Model

```csharp
// Assets/Domain/Progression/Models/TaskState.cs
using System;
using System.Collections.Generic;
using System.Linq;

public class TaskState
{
    private readonly Dictionary<string, GameTask> _tasks = new();

    public GameTask GetTask(string taskId)
    {
        return _tasks.TryGetValue(taskId, out var task) ? task : null;
    }

    public IReadOnlyList<GameTask> GetActiveTasks()
    {
        return _tasks.Values.Where(t => !t.IsCompleted).ToList();
    }

    public IReadOnlyList<GameTask> GetCompletedTasks()
    {
        return _tasks.Values.Where(t => t.IsCompleted && !t.IsClaimed).ToList();
    }

    public void SetTasks(List<GameTask> tasks)
    {
        _tasks.Clear();
        foreach (var task in tasks)
        {
            _tasks[task.Id] = task;
        }
    }

    public void UpdateProgress(string taskId, int progress)
    {
        if (_tasks.TryGetValue(taskId, out var task))
        {
            task.CurrentProgress = Math.Min(progress, task.TargetProgress);
            if (task.CurrentProgress >= task.TargetProgress)
            {
                task.IsCompleted = true;
            }
        }
    }

    public void AddProgress(string taskId, int amount)
    {
        if (_tasks.TryGetValue(taskId, out var task))
        {
            task.CurrentProgress = Math.Min(task.CurrentProgress + amount, task.TargetProgress);
            if (task.CurrentProgress >= task.TargetProgress)
            {
                task.IsCompleted = true;
            }
        }
    }

    public void MarkClaimed(string taskId)
    {
        if (_tasks.TryGetValue(taskId, out var task))
        {
            task.IsClaimed = true;
        }
    }
}

public class GameTask
{
    public string Id { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public int CurrentProgress { get; set; }
    public int TargetProgress { get; set; }
    public bool IsCompleted { get; set; }
    public bool IsClaimed { get; set; }
    public TaskReward Reward { get; set; }
}

public class TaskReward
{
    public CurrencyType CurrencyType { get; set; }
    public int Amount { get; set; }
}
```

### 4.2 Batched Task Service

```csharp
// Assets/Domain/Progression/TaskService.cs
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using VContainer;

public class TaskService : ITaskService, IDisposable
{
    private readonly TaskState _state;
    private readonly ITaskRemoteService _remoteService;
    private readonly ICurrencyService _currencyService;
    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    // Batching
    private readonly Dictionary<string, int> _pendingProgressUpdates = new();
    private readonly float _batchIntervalSeconds = 2.0f;
    private bool _batchTimerRunning;
    private System.Threading.CancellationTokenSource _batchCts;

    [Inject]
    public TaskService(
        ITaskRemoteService remoteService,
        ICurrencyService currencyService,
        IMessageBus messageBus,
        ILogger logger)
    {
        _state = new TaskState();
        _remoteService = remoteService;
        _currencyService = currencyService;
        _messageBus = messageBus;
        _logger = logger;
    }

    // ═══════════════════════════════════════════════════════════════
    // ITaskService Implementation
    // ═══════════════════════════════════════════════════════════════

    public IReadOnlyList<GameTask> GetActiveTasks() => _state.GetActiveTasks();
    public IReadOnlyList<GameTask> GetCompletedTasks() => _state.GetCompletedTasks();
    public GameTask GetTask(string taskId) => _state.GetTask(taskId);

    public event Action<TaskProgressMessage> OnTaskProgressChanged;

    /// <summary>
    /// Optimistic progress update with batching.
    /// Updates are collected and sent to server every 2 seconds.
    /// </summary>
    public void AddProgressOptimistic(string taskId, int amount)
    {
        var task = _state.GetTask(taskId);
        if (task == null || task.IsCompleted) return;

        var previousProgress = task.CurrentProgress;

        // 1. OPTIMISTIC UPDATE (immediate)
        _state.AddProgress(taskId, amount);

        // 2. Publish immediate UI update
        PublishProgress(task, isOptimistic: true);

        // 3. Queue for batch
        if (!_pendingProgressUpdates.ContainsKey(taskId))
        {
            _pendingProgressUpdates[taskId] = 0;
        }
        _pendingProgressUpdates[taskId] += amount;

        _logger.Log($"[Task] Optimistic progress: {taskId} +{amount} (queued for batch)");

        // 4. Start batch timer if not running
        StartBatchTimerIfNeeded();
    }

    public async UniTask<OperationResult> ClaimTaskRewardOptimisticAsync(string taskId)
    {
        var task = _state.GetTask(taskId);

        // Validation
        if (task == null)
            return OperationResult.ValidationError("Task not found");

        if (!task.IsCompleted)
            return OperationResult.ValidationError("Task not completed");

        if (task.IsClaimed)
            return OperationResult.ValidationError("Task already claimed");

        // Flush pending progress first
        await FlushProgressBatchAsync();

        // 1. SNAPSHOT (task state + currency)
        var taskWasClaimed = task.IsClaimed;
        var currencySnapshot = _currencyService.CreateSnapshot();

        // 2. OPTIMISTIC UPDATE
        task.IsClaimed = true;
        PublishProgress(task, isOptimistic: true);

        // Give reward optimistically
        await _currencyService.AddCurrencyOptimisticAsync(
            task.Reward.CurrencyType,
            task.Reward.Amount,
            $"task_reward_{taskId}"
        );

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.ClaimTaskRewardAsync(taskId);

            if (response.Success)
            {
                PublishProgress(task, isOptimistic: false);
                return OperationResult.Success();
            }
            else
            {
                // ROLLBACK
                task.IsClaimed = taskWasClaimed;
                _currencyService.RestoreSnapshot(currencySnapshot);
                PublishProgress(task, isOptimistic: false);
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            // ROLLBACK
            _logger.LogError($"[Task] Claim error: {ex.Message}");
            task.IsClaimed = taskWasClaimed;
            _currencyService.RestoreSnapshot(currencySnapshot);
            PublishProgress(task, isOptimistic: false);
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask SyncWithServerAsync()
    {
        // Flush pending first
        await FlushProgressBatchAsync();

        try
        {
            var serverTasks = await _remoteService.FetchTasksAsync();
            _state.SetTasks(serverTasks);

            foreach (var task in serverTasks)
            {
                PublishProgress(task, isOptimistic: false);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Task] Sync failed: {ex.Message}");
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Batching Logic
    // ═══════════════════════════════════════════════════════════════

    private void StartBatchTimerIfNeeded()
    {
        if (_batchTimerRunning) return;

        _batchTimerRunning = true;
        _batchCts = new System.Threading.CancellationTokenSource();

        RunBatchTimer(_batchCts.Token).Forget();
    }

    private async UniTaskVoid RunBatchTimer(System.Threading.CancellationToken ct)
    {
        while (!ct.IsCancellationRequested && _pendingProgressUpdates.Count > 0)
        {
            await UniTask.Delay(TimeSpan.FromSeconds(_batchIntervalSeconds), cancellationToken: ct);

            if (_pendingProgressUpdates.Count > 0)
            {
                await FlushProgressBatchAsync();
            }
        }

        _batchTimerRunning = false;
    }

    private async UniTask FlushProgressBatchAsync()
    {
        if (_pendingProgressUpdates.Count == 0) return;

        // Copy and clear
        var batch = new Dictionary<string, int>(_pendingProgressUpdates);
        _pendingProgressUpdates.Clear();

        _logger.Log($"[Task] Flushing batch: {batch.Count} tasks");

        try
        {
            var response = await _remoteService.BatchUpdateProgressAsync(batch);

            if (!response.Success)
            {
                // ROLLBACK all in batch
                foreach (var kvp in batch)
                {
                    var task = _state.GetTask(kvp.Key);
                    if (task != null)
                    {
                        task.CurrentProgress = Math.Max(0, task.CurrentProgress - kvp.Value);
                        task.IsCompleted = task.CurrentProgress >= task.TargetProgress;
                        PublishProgress(task, isOptimistic: false);
                    }
                }

                _logger.LogWarning($"[Task] Batch failed, rolled back {batch.Count} tasks");
            }
            else
            {
                // Sync with server values
                foreach (var serverTask in response.Tasks)
                {
                    var localTask = _state.GetTask(serverTask.Id);
                    if (localTask != null)
                    {
                        localTask.CurrentProgress = serverTask.CurrentProgress;
                        localTask.IsCompleted = serverTask.IsCompleted;
                        PublishProgress(localTask, isOptimistic: false);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Task] Batch error: {ex.Message}");

            // Re-queue failed batch for retry
            foreach (var kvp in batch)
            {
                if (!_pendingProgressUpdates.ContainsKey(kvp.Key))
                    _pendingProgressUpdates[kvp.Key] = 0;

                _pendingProgressUpdates[kvp.Key] += kvp.Value;
            }

            // Restart batch timer
            StartBatchTimerIfNeeded();
        }
    }

    private void PublishProgress(GameTask task, bool isOptimistic)
    {
        var message = new TaskProgressMessage(
            task.Id,
            task.CurrentProgress,
            task.TargetProgress,
            task.IsCompleted,
            isOptimistic
        );

        OnTaskProgressChanged?.Invoke(message);
        _messageBus.Publish(message);
    }

    public void Dispose()
    {
        _batchCts?.Cancel();
        _batchCts?.Dispose();
    }
}
```

---

## BÖLÜM 5: ACHIEVEMENT SERVICE

### 5.1 Service Implementation

```csharp
// Assets/Domain/Progression/AchievementService.cs
using System;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using VContainer;

public class AchievementService : IAchievementService
{
    private readonly Dictionary<string, Achievement> _achievements = new();
    private readonly IAchievementRemoteService _remoteService;
    private readonly ICurrencyService _currencyService;
    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    [Inject]
    public AchievementService(
        IAchievementRemoteService remoteService,
        ICurrencyService currencyService,
        IMessageBus messageBus,
        ILogger logger)
    {
        _remoteService = remoteService;
        _currencyService = currencyService;
        _messageBus = messageBus;
        _logger = logger;
    }

    public IReadOnlyList<Achievement> GetAllAchievements() => _achievements.Values.ToList();
    public Achievement GetAchievement(string id) => _achievements.TryGetValue(id, out var a) ? a : null;
    public bool IsUnlocked(string id) => _achievements.TryGetValue(id, out var a) && a.IsUnlocked;
    public bool IsClaimed(string id) => _achievements.TryGetValue(id, out var a) && a.IsClaimed;

    public event Action<AchievementChangedMessage> OnAchievementChanged;

    /// <summary>
    /// Optimistic progress update (no server call, batched elsewhere).
    /// </summary>
    public void UpdateProgressOptimistic(string achievementId, int progress)
    {
        if (!_achievements.TryGetValue(achievementId, out var achievement))
            return;

        if (achievement.IsUnlocked) return;

        var previousProgress = achievement.CurrentProgress;
        achievement.CurrentProgress = Math.Min(progress, achievement.TargetProgress);

        // Check for unlock
        if (achievement.CurrentProgress >= achievement.TargetProgress)
        {
            achievement.IsUnlocked = true;
            PublishChange(achievementId, AchievementChangeType.Unlocked, true);

            _logger.Log($"[Achievement] Unlocked: {achievementId}");
        }
        else
        {
            PublishChange(achievementId, AchievementChangeType.ProgressUpdated, true);
        }
    }

    public async UniTask<OperationResult> ClaimAchievementOptimisticAsync(string achievementId)
    {
        if (!_achievements.TryGetValue(achievementId, out var achievement))
            return OperationResult.ValidationError("Achievement not found");

        if (!achievement.IsUnlocked)
            return OperationResult.ValidationError("Achievement not unlocked");

        if (achievement.IsClaimed)
            return OperationResult.ValidationError("Achievement already claimed");

        // 1. SNAPSHOT
        var wasUnlocked = achievement.IsUnlocked;
        var wasClaimed = achievement.IsClaimed;
        var currencySnapshot = _currencyService.CreateSnapshot();

        // 2. OPTIMISTIC UPDATE
        achievement.IsClaimed = true;
        PublishChange(achievementId, AchievementChangeType.Claimed, true);

        // Give reward optimistically
        var rewardResult = await _currencyService.AddCurrencyOptimisticAsync(
            achievement.Reward.CurrencyType,
            achievement.Reward.Amount,
            $"achievement_{achievementId}"
        );

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.ClaimAchievementAsync(achievementId);

            if (response.Success)
            {
                PublishChange(achievementId, AchievementChangeType.Claimed, false);
                return OperationResult.Success();
            }
            else
            {
                // ROLLBACK
                achievement.IsUnlocked = wasUnlocked;
                achievement.IsClaimed = wasClaimed;
                _currencyService.RestoreSnapshot(currencySnapshot);
                PublishChange(achievementId, AchievementChangeType.RolledBack, false);
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            // ROLLBACK
            _logger.LogError($"[Achievement] Claim error: {ex.Message}");
            achievement.IsUnlocked = wasUnlocked;
            achievement.IsClaimed = wasClaimed;
            _currencyService.RestoreSnapshot(currencySnapshot);
            PublishChange(achievementId, AchievementChangeType.RolledBack, false);
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask SyncWithServerAsync()
    {
        try
        {
            var serverAchievements = await _remoteService.FetchAchievementsAsync();

            _achievements.Clear();
            foreach (var achievement in serverAchievements)
            {
                _achievements[achievement.Id] = achievement;
            }

            _messageBus.Publish(new AchievementsSyncedMessage());
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Achievement] Sync failed: {ex.Message}");
        }
    }

    private void PublishChange(string id, AchievementChangeType type, bool isOptimistic)
    {
        var message = new AchievementChangedMessage(id, type, isOptimistic);
        OnAchievementChanged?.Invoke(message);
        _messageBus.Publish(message);
    }
}

public class Achievement
{
    public string Id { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public int CurrentProgress { get; set; }
    public int TargetProgress { get; set; }
    public bool IsUnlocked { get; set; }
    public bool IsClaimed { get; set; }
    public AchievementReward Reward { get; set; }
}

public class AchievementReward
{
    public CurrencyType CurrencyType { get; set; }
    public int Amount { get; set; }
}
```

---

## BÖLÜM 6: ENERGY SERVICE

### 6.1 Service Implementation

```csharp
// Assets/Domain/Gameplay/EnergyService.cs
using System;
using Cysharp.Threading.Tasks;
using VContainer;

public class EnergyService : IEnergyService
{
    private int _currentEnergy;
    private int _maxEnergy = 5;
    private DateTime _nextRegenTime;

    private readonly IEnergyRemoteService _remoteService;
    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    [Inject]
    public EnergyService(
        IEnergyRemoteService remoteService,
        IMessageBus messageBus,
        ILogger logger)
    {
        _remoteService = remoteService;
        _messageBus = messageBus;
        _logger = logger;
    }

    public int CurrentEnergy => _currentEnergy;
    public int MaxEnergy => _maxEnergy;
    public DateTime NextRegenTime => _nextRegenTime;
    public bool HasEnoughEnergy(int amount) => _currentEnergy >= amount;

    public event Action<int, int> OnEnergyChanged;

    public async UniTask<OperationResult> ConsumeEnergyOptimisticAsync(int amount)
    {
        if (amount <= 0)
            return OperationResult.ValidationError("Amount must be positive");

        if (_currentEnergy < amount)
            return OperationResult.ValidationError("Insufficient energy");

        // 1. SNAPSHOT
        var previousEnergy = _currentEnergy;

        // 2. OPTIMISTIC UPDATE
        _currentEnergy -= amount;
        OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
        _messageBus.Publish(new EnergyChangedMessage(_currentEnergy, _maxEnergy, true));

        _logger.Log($"[Energy] Optimistic consume: -{amount}");

        // 3. SERVER REQUEST
        try
        {
            var response = await _remoteService.ConsumeEnergyAsync(amount);

            if (response.Success)
            {
                // Sync with server
                _currentEnergy = response.CurrentEnergy;
                _nextRegenTime = response.NextRegenTime;
                OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
                _messageBus.Publish(new EnergyChangedMessage(_currentEnergy, _maxEnergy, false));
                return OperationResult.Success();
            }
            else
            {
                // ROLLBACK
                _currentEnergy = previousEnergy;
                OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
                _messageBus.Publish(new EnergyChangedMessage(_currentEnergy, _maxEnergy, false));
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            // ROLLBACK
            _logger.LogError($"[Energy] Consume error: {ex.Message}");
            _currentEnergy = previousEnergy;
            OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
            _messageBus.Publish(new EnergyChangedMessage(_currentEnergy, _maxEnergy, false));
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask<OperationResult> RefillEnergyOptimisticAsync()
    {
        // 1. SNAPSHOT
        var previousEnergy = _currentEnergy;

        // 2. OPTIMISTIC UPDATE
        _currentEnergy = _maxEnergy;
        OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);

        // 3. SERVER REQUEST (Ad-based or IAP-based)
        try
        {
            var response = await _remoteService.RefillEnergyAsync();

            if (response.Success)
            {
                _currentEnergy = response.CurrentEnergy;
                _nextRegenTime = response.NextRegenTime;
                OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
                return OperationResult.Success();
            }
            else
            {
                _currentEnergy = previousEnergy;
                OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
                return OperationResult.RolledBack(response.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Energy] Refill error: {ex.Message}");
            _currentEnergy = previousEnergy;
            OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);
            return OperationResult.NetworkError(ex);
        }
    }

    public async UniTask<EnergySnapshot> FetchSnapshotAsync()
    {
        try
        {
            var response = await _remoteService.FetchEnergyStateAsync();
            _currentEnergy = response.CurrentEnergy;
            _maxEnergy = response.MaxEnergy;
            _nextRegenTime = response.NextRegenTime;

            OnEnergyChanged?.Invoke(_currentEnergy, _maxEnergy);

            return new EnergySnapshot(_currentEnergy, _maxEnergy, _nextRegenTime);
        }
        catch (Exception ex)
        {
            _logger.LogError($"[Energy] Fetch error: {ex.Message}");
            return new EnergySnapshot(_currentEnergy, _maxEnergy, _nextRegenTime);
        }
    }
}

public readonly struct EnergySnapshot
{
    public int Current { get; }
    public int Max { get; }
    public DateTime NextRegenTime { get; }

    public EnergySnapshot(int current, int max, DateTime nextRegenTime)
    {
        Current = current;
        Max = max;
        NextRegenTime = nextRegenTime;
    }
}

public readonly struct EnergyChangedMessage : IMessage
{
    public int Current { get; }
    public int Max { get; }
    public bool IsOptimistic { get; }

    public EnergyChangedMessage(int current, int max, bool isOptimistic)
    {
        Current = current;
        Max = max;
        IsOptimistic = isOptimistic;
    }
}
```

---

## BÖLÜM 7: REMOTE SERVICE IMPLEMENTATIONS

### 7.1 Firebase Gateway Pattern

```csharp
// Assets/Infrastructure/Firebase/FirebaseGateway.cs
using Firebase;
using Firebase.Functions;
using Firebase.Firestore;
using Cysharp.Threading.Tasks;

/// <summary>
/// Central Firebase access point.
/// All Firebase calls go through here for consistent error handling and logging.
/// </summary>
public class FirebaseGateway : IFirebaseGateway
{
    private readonly ILogger _logger;
    private FirebaseFunctions _functions;
    private FirebaseFirestore _firestore;

    public FirebaseGateway(ILogger logger)
    {
        _logger = logger;
    }

    public async UniTask InitializeAsync()
    {
        var dependencyStatus = await FirebaseApp.CheckAndFixDependenciesAsync();
        if (dependencyStatus != DependencyStatus.Available)
        {
            throw new Exception($"Firebase dependencies not available: {dependencyStatus}");
        }

        _functions = FirebaseFunctions.GetInstance(FirebaseApp.DefaultInstance, "us-central1");
        _firestore = FirebaseFirestore.DefaultInstance;

        _logger.Log("[Firebase] Initialized successfully");
    }

    public async UniTask<T> CallFunctionAsync<T>(string functionName, object data = null)
    {
        try
        {
            _logger.Log($"[Firebase] Calling function: {functionName}");

            var callable = _functions.GetHttpsCallable(functionName);
            var result = await callable.CallAsync(data);

            return ParseResult<T>(result.Data);
        }
        catch (FunctionsException ex)
        {
            _logger.LogError($"[Firebase] Function error ({functionName}): {ex.ErrorCode} - {ex.Message}");
            throw;
        }
    }

    public async UniTask<DocumentSnapshot> GetDocumentAsync(string collection, string documentId)
    {
        var docRef = _firestore.Collection(collection).Document(documentId);
        return await docRef.GetSnapshotAsync();
    }

    public async UniTask SetDocumentAsync(string collection, string documentId, object data)
    {
        var docRef = _firestore.Collection(collection).Document(documentId);
        await docRef.SetAsync(data, SetOptions.MergeAll);
    }

    private T ParseResult<T>(object data)
    {
        // JSON parsing logic
        var json = Newtonsoft.Json.JsonConvert.SerializeObject(data);
        return Newtonsoft.Json.JsonConvert.DeserializeObject<T>(json);
    }
}
```

### 7.2 Inventory Remote Service

```csharp
// Assets/Infrastructure/Firebase/InventoryRemoteService.cs
public class InventoryRemoteService : IInventoryRemoteService
{
    private readonly IFirebaseGateway _firebase;
    private readonly ILogger _logger;

    public InventoryRemoteService(IFirebaseGateway firebase, ILogger logger)
    {
        _firebase = firebase;
        _logger = logger;
    }

    public async UniTask<EquipItemResponse> EquipItemAsync(string itemId, string slotId)
    {
        var result = await _firebase.CallFunctionAsync<EquipItemResponse>(
            "equipItem",
            new { itemId, slotId }
        );
        return result;
    }

    public async UniTask<UnequipItemResponse> UnequipItemAsync(string itemId)
    {
        var result = await _firebase.CallFunctionAsync<UnequipItemResponse>(
            "unequipItem",
            new { itemId }
        );
        return result;
    }

    public async UniTask<AcquireItemResponse> AcquireItemAsync(string itemId, string source)
    {
        var result = await _firebase.CallFunctionAsync<AcquireItemResponse>(
            "acquireItem",
            new { itemId, source }
        );
        return result;
    }

    public async UniTask<InventoryStateResponse> FetchInventoryAsync()
    {
        var result = await _firebase.CallFunctionAsync<InventoryStateResponse>(
            "getInventory",
            null
        );
        return result;
    }
}
```

---

## BÖLÜM 8: MIGRATION FROM EXISTING CODE

### 8.1 UserDatabaseManager → Service Migration

**Mevcut Kod (UserDatabaseManager.cs - 1624 satır):**
```csharp
// Mevcut - Her şey tek class'ta
public class UserDatabaseManager : MonoBehaviour
{
    public static UserDatabaseManager Instance;

    // Auth methods
    public async Task LoginWithGoogle() { ... }
    public async Task LoginWithApple() { ... }

    // Currency methods
    public void AddCurrency(int amount) { ... }
    public void SpendCurrency(int amount) { ... }

    // Inventory methods
    public void EquipItem(string id) { ... }

    // ... 1600+ satır daha
}
```

**Yeni Yapı:**
```
UserDatabaseManager (1624 lines)
    │
    ├── AuthService (IAuthService)
    │   └── ~150 lines
    │
    ├── CurrencyService (ICurrencyService)
    │   └── ~200 lines
    │
    ├── InventoryService (IInventoryService)
    │   └── ~250 lines
    │
    ├── TaskService (ITaskService)
    │   └── ~200 lines
    │
    ├── AchievementService (IAchievementService)
    │   └── ~200 lines
    │
    └── EnergyService (IEnergyService)
        └── ~150 lines
```

### 8.2 Step-by-Step Migration

**Step 1: Interface'leri Tanımla** (Phase 1'de tamamlandı)

**Step 2: Yeni Service'i Oluştur**
```csharp
// Yeni CurrencyService
public class CurrencyService : ICurrencyService { ... }
```

**Step 3: Bridge ile Eski Kodu Sarmalı**
```csharp
// Geçiş döneminde UserDatabaseManager'dan delegation
public class UserDatabaseManager : MonoBehaviour
{
    [Inject] private ICurrencyService _currencyService;

    // Eski method - yeni service'e delegate et
    public void AddCurrency(int amount)
    {
        // Fire and forget geçici olarak
        _currencyService.AddCurrencyOptimisticAsync(CurrencyType.Coin, amount, "legacy")
            .Forget();
    }
}
```

**Step 4: Consumer'ları Güncelle**
```csharp
// Eski kod
UserDatabaseManager.Instance.AddCurrency(100);

// Yeni kod
[Inject] private ICurrencyService _currencyService;

async void OnCoinCollected()
{
    var result = await _currencyService.AddCurrencyOptimisticAsync(
        CurrencyType.Coin,
        100,
        "gameplay_collect"
    );

    if (!result.IsSuccess)
    {
        // Handle failure
    }
}
```

**Step 5: Eski Kodu Kaldır**
```csharp
// UserDatabaseManager'dan method'u sil
// Artık sadece ICurrencyService kullanılıyor
```

---

## BÖLÜM 9: TESTING STRATEGY

### 9.1 Mock Remote Services

```csharp
// Assets/Tests/Mocks/MockCurrencyRemoteService.cs
public class MockCurrencyRemoteService : ICurrencyRemoteService
{
    public bool ShouldSucceed { get; set; } = true;
    public int ResponseDelay { get; set; } = 100;
    public string ErrorMessage { get; set; } = "Mock error";

    private int _balance = 1000;

    public async UniTask<CurrencyOperationResponse> AddCurrencyAsync(
        CurrencyType type, int amount, string source)
    {
        await UniTask.Delay(ResponseDelay);

        if (!ShouldSucceed)
        {
            return new CurrencyOperationResponse
            {
                Success = false,
                ErrorMessage = ErrorMessage
            };
        }

        _balance += amount;
        return new CurrencyOperationResponse
        {
            Success = true,
            NewBalance = _balance
        };
    }

    public async UniTask<CurrencyOperationResponse> SpendCurrencyAsync(
        CurrencyType type, int amount, string reason)
    {
        await UniTask.Delay(ResponseDelay);

        if (!ShouldSucceed || _balance < amount)
        {
            return new CurrencyOperationResponse
            {
                Success = false,
                ErrorMessage = _balance < amount ? "Insufficient balance" : ErrorMessage
            };
        }

        _balance -= amount;
        return new CurrencyOperationResponse
        {
            Success = true,
            NewBalance = _balance
        };
    }

    public async UniTask<CurrencyBalancesResponse> FetchBalancesAsync()
    {
        await UniTask.Delay(ResponseDelay);

        return new CurrencyBalancesResponse
        {
            Balances = new Dictionary<CurrencyType, int>
            {
                { CurrencyType.Coin, _balance }
            }
        };
    }
}
```

### 9.2 Unit Test Examples

```csharp
// Assets/Tests/Services/CurrencyServiceTests.cs
[TestFixture]
public class CurrencyServiceTests
{
    private CurrencyService _service;
    private MockCurrencyRemoteService _mockRemote;
    private MockMessageBus _mockMessageBus;

    [SetUp]
    public void Setup()
    {
        _mockRemote = new MockCurrencyRemoteService();
        _mockMessageBus = new MockMessageBus();
        _service = new CurrencyService(_mockRemote, _mockMessageBus, new NullLogger());
    }

    [Test]
    public async Task AddCurrency_Success_UpdatesBalanceAndPublishesEvent()
    {
        // Arrange
        _mockRemote.ShouldSucceed = true;

        // Act
        var result = await _service.AddCurrencyOptimisticAsync(CurrencyType.Coin, 100, "test");

        // Assert
        Assert.IsTrue(result.IsSuccess);
        Assert.AreEqual(100, _service.GetBalance(CurrencyType.Coin));
        Assert.AreEqual(2, _mockMessageBus.PublishedMessages.Count); // Optimistic + Confirmed
    }

    [Test]
    public async Task AddCurrency_ServerFailure_RollsBackAndReturnsError()
    {
        // Arrange
        _mockRemote.ShouldSucceed = false;

        // Act
        var result = await _service.AddCurrencyOptimisticAsync(CurrencyType.Coin, 100, "test");

        // Assert
        Assert.IsFalse(result.IsSuccess);
        Assert.AreEqual(OperationStatus.RolledBack, result.Status);
        Assert.AreEqual(0, _service.GetBalance(CurrencyType.Coin));
    }

    [Test]
    public async Task SpendCurrency_InsufficientBalance_ReturnsValidationError()
    {
        // Arrange
        // Balance is 0

        // Act
        var result = await _service.SpendCurrencyOptimisticAsync(CurrencyType.Coin, 100, "test");

        // Assert
        Assert.AreEqual(OperationStatus.ValidationError, result.Status);
    }
}
```

---

## BÖLÜM 10: FILE INVENTORY

Bu fazda oluşturulacak/güncellenecek dosyalar:

```
Assets/Domain/
├── Economy/
│   ├── Models/
│   │   ├── CurrencyState.cs              [YENİ]
│   │   ├── CurrencySnapshot.cs           [YENİ]
│   │   ├── InventoryState.cs             [YENİ]
│   │   └── InventorySnapshot.cs          [YENİ]
│   ├── CurrencyService.cs                [YENİ]
│   └── InventoryService.cs               [YENİ]
│
├── Progression/
│   ├── Models/
│   │   ├── TaskState.cs                  [YENİ]
│   │   └── Achievement.cs                [YENİ]
│   ├── TaskService.cs                    [YENİ]
│   └── AchievementService.cs             [YENİ]
│
└── Gameplay/
    ├── EnergyService.cs                  [YENİ]
    └── SessionService.cs                 [YENİ]

Assets/Infrastructure/
├── Firebase/
│   ├── FirebaseGateway.cs                [YENİ]
│   ├── IFirebaseGateway.cs               [YENİ]
│   ├── CurrencyRemoteService.cs          [YENİ]
│   ├── InventoryRemoteService.cs         [YENİ]
│   ├── TaskRemoteService.cs              [YENİ]
│   ├── AchievementRemoteService.cs       [YENİ]
│   └── EnergyRemoteService.cs            [YENİ]
│
└── Logging/
    └── UnityLogger.cs                    [YENİ]

Assets/Tests/
├── Mocks/
│   ├── MockCurrencyRemoteService.cs      [YENİ]
│   ├── MockInventoryRemoteService.cs     [YENİ]
│   └── MockMessageBus.cs                 [YENİ]
│
└── Services/
    ├── CurrencyServiceTests.cs           [YENİ]
    ├── InventoryServiceTests.cs          [YENİ]
    └── TaskServiceTests.cs               [YENİ]
```

**Toplam:** ~25 yeni dosya

---

## SONRAKI ADIMLAR

Bu faz tamamlandığında:
1. Tüm servisler DI container'da register edilmiş
2. Optimistic pattern tüm servislerde uygulanmış
3. MessageBus üzerinden event'ler yayınlanıyor
4. Firebase çağrıları soyutlanmış
5. Unit test altyapısı hazır

**Sonraki döküman:** [01.3_PHASE_THREE_UI_AND_GAMEPLAY.md](01.3_PHASE_THREE_UI_AND_GAMEPLAY.md)

---

*Bu döküman Phase 2 Service Layer v1.0'dır.*
