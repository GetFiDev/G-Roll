# Phase 3: UI Navigation & Gameplay Refactoring

**Referans:** [01_ARCHITECTURE_ANALYSIS_REPORT.md](01_ARCHITECTURE_ANALYSIS_REPORT.md)
**Önkoşul:** [01.2_PHASE_TWO_SERVICE_LAYER.md](01.2_PHASE_TWO_SERVICE_LAYER.md)
**Felsefe:** [00_OPTIMISTIC_CLIENT_ARCHITECTURE.md](00_OPTIMISTIC_CLIENT_ARCHITECTURE.md)
**Versiyon:** 1.0

---

## EXECUTIVE SUMMARY

Bu döküman, G-Roll projesinin son refactoring fazını tanımlar:

1. **UI Navigation Framework** - Screen/Popup yönetimi, back button handling
2. **Optimistic UI Feedback** - Loading states, rollback animations
3. **Gameplay Refactoring** - PlayerMovement split, state machine
4. **Manager Class Cleanup** - God class'ların parçalanması

---

## PRE-FLIGHT CHECKLIST

Bu faza başlamadan önce:

- [ ] Phase 1 ve Phase 2 tamamlanmış olmalı
- [ ] Tüm servisler DI üzerinden çalışıyor
- [ ] MessageBus event'leri düzgün çalışıyor
- [ ] Branch: `refactor/phase-3-ui-gameplay`

---

## BÖLÜM 1: UI NAVIGATION FRAMEWORK

### 1.1 Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         UI ARCHITECTURE                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Navigation Service                            │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │   │
│  │  │ Screen Stack │  │ Popup Stack  │  │  Transition Manager  │  │   │
│  │  └──────────────┘  └──────────────┘  └──────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                   │                                      │
│                     ┌─────────────┴─────────────┐                       │
│                     ▼                           ▼                        │
│  ┌────────────────────────────┐  ┌────────────────────────────┐        │
│  │         SCREENS            │  │          POPUPS            │        │
│  │  ┌──────────────────────┐  │  │  ┌──────────────────────┐  │        │
│  │  │     UIScreenBase     │  │  │  │     UIPopupBase      │  │        │
│  │  │  - OnScreenEnter()   │  │  │  │  - OnPopupShow()     │  │        │
│  │  │  - OnScreenExit()    │  │  │  │  - OnPopupHide()     │  │        │
│  │  │  - OnBackPressed()   │  │  │  │  - OnBackPressed()   │  │        │
│  │  └──────────────────────┘  │  │  └──────────────────────┘  │        │
│  │           ▲                │  │           ▲                │        │
│  │     ┌─────┴─────┐          │  │     ┌─────┴─────┐          │        │
│  │     ▼           ▼          │  │     ▼           ▼          │        │
│  │ ┌────────┐ ┌────────┐      │  │ ┌────────┐ ┌────────┐      │        │
│  │ │  Home  │ │  Shop  │      │  │ │Settings│ │Purchase│      │        │
│  │ │ Screen │ │ Screen │      │  │ │ Popup  │ │ Popup  │      │        │
│  │ └────────┘ └────────┘      │  │ └────────┘ └────────┘      │        │
│  └────────────────────────────┘  └────────────────────────────┘        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 Base Classes

```csharp
// Assets/Presentation/Core/UIScreenBase.cs
using System;
using Cysharp.Threading.Tasks;
using UnityEngine;
using VContainer;

/// <summary>
/// Base class for all full-screen UI screens.
/// Screens are mutually exclusive - only one is visible at a time.
/// </summary>
public abstract class UIScreenBase : MonoBehaviour
{
    [Header("Screen Settings")]
    [SerializeField] protected CanvasGroup canvasGroup;
    [SerializeField] protected float transitionDuration = 0.3f;

    [Inject] protected INavigationService NavigationService;
    [Inject] protected IMessageBus MessageBus;
    [Inject] protected IFeedbackService FeedbackService;

    protected CompositeDisposable Subscriptions = new();

    public bool IsVisible { get; private set; }

    // ═══════════════════════════════════════════════════════════════
    // Lifecycle Methods (Override in subclasses)
    // ═══════════════════════════════════════════════════════════════

    /// <summary>
    /// Called when screen is about to be shown.
    /// Use for initialization, data loading, subscriptions.
    /// </summary>
    protected virtual UniTask OnScreenEnterAsync(object parameters) => UniTask.CompletedTask;

    /// <summary>
    /// Called after screen transition completes.
    /// Use for animations, focus handling.
    /// </summary>
    protected virtual void OnScreenEnterComplete() { }

    /// <summary>
    /// Called when screen is about to be hidden.
    /// Use for cleanup, saving state.
    /// </summary>
    protected virtual UniTask OnScreenExitAsync() => UniTask.CompletedTask;

    /// <summary>
    /// Called after screen is fully hidden.
    /// Use for unsubscriptions, releasing resources.
    /// </summary>
    protected virtual void OnScreenExitComplete() { }

    /// <summary>
    /// Called when back button is pressed.
    /// Return true if handled, false to let navigation service handle it.
    /// </summary>
    protected virtual bool OnBackPressed() => false;

    // ═══════════════════════════════════════════════════════════════
    // Internal Methods (Called by NavigationService)
    // ═══════════════════════════════════════════════════════════════

    internal async UniTask ShowAsync(object parameters)
    {
        gameObject.SetActive(true);
        IsVisible = true;

        await OnScreenEnterAsync(parameters);
        await PlayEnterTransitionAsync();

        OnScreenEnterComplete();
    }

    internal async UniTask HideAsync()
    {
        await OnScreenExitAsync();
        await PlayExitTransitionAsync();

        IsVisible = false;
        gameObject.SetActive(false);

        OnScreenExitComplete();
        Subscriptions.Dispose();
        Subscriptions = new CompositeDisposable();
    }

    internal bool HandleBackPress()
    {
        return OnBackPressed();
    }

    // ═══════════════════════════════════════════════════════════════
    // Transition Animations
    // ═══════════════════════════════════════════════════════════════

    protected virtual async UniTask PlayEnterTransitionAsync()
    {
        if (canvasGroup == null) return;

        canvasGroup.alpha = 0f;
        canvasGroup.interactable = false;

        await canvasGroup.DOFade(1f, transitionDuration)
            .SetEase(Ease.OutQuad)
            .ToUniTask();

        canvasGroup.interactable = true;
    }

    protected virtual async UniTask PlayExitTransitionAsync()
    {
        if (canvasGroup == null) return;

        canvasGroup.interactable = false;

        await canvasGroup.DOFade(0f, transitionDuration)
            .SetEase(Ease.InQuad)
            .ToUniTask();
    }
}
```

```csharp
// Assets/Presentation/Core/UIPopupBase.cs
using System;
using Cysharp.Threading.Tasks;
using UnityEngine;
using VContainer;

/// <summary>
/// Base class for popup dialogs.
/// Popups can stack on top of each other and screens.
/// </summary>
public abstract class UIPopupBase : MonoBehaviour
{
    [Header("Popup Settings")]
    [SerializeField] protected CanvasGroup canvasGroup;
    [SerializeField] protected RectTransform contentTransform;
    [SerializeField] protected float transitionDuration = 0.25f;
    [SerializeField] protected bool closeOnBackgroundClick = true;
    [SerializeField] protected bool closeOnBackButton = true;

    [Inject] protected INavigationService NavigationService;
    [Inject] protected IMessageBus MessageBus;
    [Inject] protected IFeedbackService FeedbackService;

    protected CompositeDisposable Subscriptions = new();

    public bool IsVisible { get; private set; }

    /// <summary>
    /// Result to return when popup closes.
    /// Set this before calling Close().
    /// </summary>
    protected object Result { get; set; }

    // ═══════════════════════════════════════════════════════════════
    // Lifecycle Methods
    // ═══════════════════════════════════════════════════════════════

    protected virtual UniTask OnPopupShowAsync(object parameters) => UniTask.CompletedTask;
    protected virtual void OnPopupShowComplete() { }
    protected virtual UniTask OnPopupHideAsync() => UniTask.CompletedTask;
    protected virtual void OnPopupHideComplete() { }

    /// <summary>
    /// Called when back button pressed.
    /// Return true to prevent default close behavior.
    /// </summary>
    protected virtual bool OnBackPressed() => false;

    // ═══════════════════════════════════════════════════════════════
    // Public Methods
    // ═══════════════════════════════════════════════════════════════

    public void OnBackgroundClicked()
    {
        if (closeOnBackgroundClick)
        {
            Close();
        }
    }

    public void Close()
    {
        NavigationService.HidePopupAsync(this).Forget();
    }

    public void CloseWithResult(object result)
    {
        Result = result;
        Close();
    }

    // ═══════════════════════════════════════════════════════════════
    // Internal Methods
    // ═══════════════════════════════════════════════════════════════

    internal async UniTask<object> ShowAsync(object parameters)
    {
        gameObject.SetActive(true);
        IsVisible = true;
        Result = null;

        await OnPopupShowAsync(parameters);
        await PlayShowTransitionAsync();

        OnPopupShowComplete();

        // Wait until closed
        await UniTask.WaitUntil(() => !IsVisible);

        return Result;
    }

    internal async UniTask HideAsync()
    {
        await OnPopupHideAsync();
        await PlayHideTransitionAsync();

        IsVisible = false;
        gameObject.SetActive(false);

        OnPopupHideComplete();
        Subscriptions.Dispose();
        Subscriptions = new CompositeDisposable();
    }

    internal bool HandleBackPress()
    {
        if (OnBackPressed())
            return true;

        if (closeOnBackButton)
        {
            Close();
            return true;
        }

        return false;
    }

    // ═══════════════════════════════════════════════════════════════
    // Transition Animations
    // ═══════════════════════════════════════════════════════════════

    protected virtual async UniTask PlayShowTransitionAsync()
    {
        if (canvasGroup != null)
        {
            canvasGroup.alpha = 0f;
        }

        if (contentTransform != null)
        {
            contentTransform.localScale = Vector3.one * 0.8f;
        }

        var tasks = new List<UniTask>();

        if (canvasGroup != null)
        {
            tasks.Add(canvasGroup.DOFade(1f, transitionDuration).ToUniTask());
        }

        if (contentTransform != null)
        {
            tasks.Add(contentTransform.DOScale(1f, transitionDuration)
                .SetEase(Ease.OutBack)
                .ToUniTask());
        }

        await UniTask.WhenAll(tasks);

        if (canvasGroup != null)
        {
            canvasGroup.interactable = true;
        }
    }

    protected virtual async UniTask PlayHideTransitionAsync()
    {
        if (canvasGroup != null)
        {
            canvasGroup.interactable = false;
        }

        var tasks = new List<UniTask>();

        if (canvasGroup != null)
        {
            tasks.Add(canvasGroup.DOFade(0f, transitionDuration * 0.75f).ToUniTask());
        }

        if (contentTransform != null)
        {
            tasks.Add(contentTransform.DOScale(0.8f, transitionDuration * 0.75f)
                .SetEase(Ease.InBack)
                .ToUniTask());
        }

        await UniTask.WhenAll(tasks);
    }
}
```

### 1.3 Navigation Service Implementation

```csharp
// Assets/Presentation/Navigation/NavigationService.cs
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;
using VContainer;

public class NavigationService : INavigationService
{
    private readonly Stack<UIScreenBase> _screenStack = new();
    private readonly Stack<UIPopupBase> _popupStack = new();

    private readonly Dictionary<Type, UIScreenBase> _screenRegistry = new();
    private readonly Dictionary<Type, UIPopupBase> _popupRegistry = new();

    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    private bool _isTransitioning;

    public UIScreenBase CurrentScreen => _screenStack.Count > 0 ? _screenStack.Peek() : null;
    public bool CanGoBack => _screenStack.Count > 1 || _popupStack.Count > 0;

    public event Action<UIScreenBase> OnScreenChanged;

    [Inject]
    public NavigationService(IMessageBus messageBus, ILogger logger)
    {
        _messageBus = messageBus;
        _logger = logger;
    }

    // ═══════════════════════════════════════════════════════════════
    // Registration
    // ═══════════════════════════════════════════════════════════════

    public void RegisterScreen<T>(T screen) where T : UIScreenBase
    {
        _screenRegistry[typeof(T)] = screen;
        screen.gameObject.SetActive(false);
    }

    public void RegisterPopup<T>(T popup) where T : UIPopupBase
    {
        _popupRegistry[typeof(T)] = popup;
        popup.gameObject.SetActive(false);
    }

    // ═══════════════════════════════════════════════════════════════
    // Screen Navigation
    // ═══════════════════════════════════════════════════════════════

    public async UniTask PushScreenAsync<T>(object parameters = null) where T : UIScreenBase
    {
        if (_isTransitioning)
        {
            _logger.LogWarning("[Navigation] Transition in progress, ignoring push");
            return;
        }

        if (!_screenRegistry.TryGetValue(typeof(T), out var screen))
        {
            _logger.LogError($"[Navigation] Screen not registered: {typeof(T).Name}");
            return;
        }

        _isTransitioning = true;

        try
        {
            // Hide current screen (but keep in stack)
            if (_screenStack.Count > 0)
            {
                var currentScreen = _screenStack.Peek();
                await currentScreen.HideAsync();
            }

            // Show new screen
            _screenStack.Push(screen);
            await screen.ShowAsync(parameters);

            OnScreenChanged?.Invoke(screen);
            _messageBus.Publish(new ScreenChangedMessage(typeof(T).Name));

            _logger.Log($"[Navigation] Pushed screen: {typeof(T).Name}");
        }
        finally
        {
            _isTransitioning = false;
        }
    }

    public async UniTask PopScreenAsync()
    {
        if (_isTransitioning)
        {
            _logger.LogWarning("[Navigation] Transition in progress, ignoring pop");
            return;
        }

        if (_screenStack.Count <= 1)
        {
            _logger.LogWarning("[Navigation] Cannot pop root screen");
            return;
        }

        _isTransitioning = true;

        try
        {
            // Hide and remove current screen
            var currentScreen = _screenStack.Pop();
            await currentScreen.HideAsync();

            // Show previous screen
            var previousScreen = _screenStack.Peek();
            await previousScreen.ShowAsync(null);

            OnScreenChanged?.Invoke(previousScreen);
            _messageBus.Publish(new ScreenChangedMessage(previousScreen.GetType().Name));

            _logger.Log($"[Navigation] Popped to screen: {previousScreen.GetType().Name}");
        }
        finally
        {
            _isTransitioning = false;
        }
    }

    public async UniTask PopToRootAsync()
    {
        if (_isTransitioning) return;

        while (_screenStack.Count > 1)
        {
            await PopScreenAsync();
        }
    }

    public async UniTask ReplaceScreenAsync<T>(object parameters = null) where T : UIScreenBase
    {
        if (_isTransitioning) return;

        if (!_screenRegistry.TryGetValue(typeof(T), out var screen))
        {
            _logger.LogError($"[Navigation] Screen not registered: {typeof(T).Name}");
            return;
        }

        _isTransitioning = true;

        try
        {
            // Hide and remove current screen
            if (_screenStack.Count > 0)
            {
                var currentScreen = _screenStack.Pop();
                await currentScreen.HideAsync();
            }

            // Show new screen
            _screenStack.Push(screen);
            await screen.ShowAsync(parameters);

            OnScreenChanged?.Invoke(screen);
        }
        finally
        {
            _isTransitioning = false;
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Popup Navigation
    // ═══════════════════════════════════════════════════════════════

    public async UniTask<T> ShowPopupAsync<T>(object parameters = null) where T : UIPopupBase
    {
        if (!_popupRegistry.TryGetValue(typeof(T), out var popup))
        {
            _logger.LogError($"[Navigation] Popup not registered: {typeof(T).Name}");
            return null;
        }

        _popupStack.Push(popup);

        _logger.Log($"[Navigation] Showing popup: {typeof(T).Name}");

        var result = await popup.ShowAsync(parameters);

        return popup as T;
    }

    public async UniTask HidePopupAsync<T>() where T : UIPopupBase
    {
        if (!_popupRegistry.TryGetValue(typeof(T), out var popup))
            return;

        await HidePopupAsync(popup);
    }

    internal async UniTask HidePopupAsync(UIPopupBase popup)
    {
        if (!popup.IsVisible) return;

        await popup.HideAsync();

        // Remove from stack
        var tempStack = new Stack<UIPopupBase>();
        while (_popupStack.Count > 0)
        {
            var p = _popupStack.Pop();
            if (p != popup)
            {
                tempStack.Push(p);
            }
        }
        while (tempStack.Count > 0)
        {
            _popupStack.Push(tempStack.Pop());
        }

        _logger.Log($"[Navigation] Hidden popup: {popup.GetType().Name}");
    }

    public async UniTask HideAllPopupsAsync()
    {
        while (_popupStack.Count > 0)
        {
            var popup = _popupStack.Pop();
            await popup.HideAsync();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Back Button Handling
    // ═══════════════════════════════════════════════════════════════

    public bool HandleBackButton()
    {
        // First, try popups
        if (_popupStack.Count > 0)
        {
            var topPopup = _popupStack.Peek();
            if (topPopup.HandleBackPress())
            {
                return true;
            }
        }

        // Then, try current screen
        if (_screenStack.Count > 0)
        {
            var currentScreen = _screenStack.Peek();
            if (currentScreen.HandleBackPress())
            {
                return true;
            }
        }

        // Default: pop screen if possible
        if (_screenStack.Count > 1)
        {
            PopScreenAsync().Forget();
            return true;
        }

        return false;
    }
}

// Message for screen changes
public readonly struct ScreenChangedMessage : IMessage
{
    public string ScreenName { get; }

    public ScreenChangedMessage(string screenName)
    {
        ScreenName = screenName;
    }
}
```

### 1.4 Back Button Handler

```csharp
// Assets/Presentation/Navigation/BackButtonHandler.cs
using UnityEngine;
using VContainer;

/// <summary>
/// MonoBehaviour that listens for Android back button and escape key.
/// </summary>
public class BackButtonHandler : MonoBehaviour
{
    [Inject] private INavigationService _navigationService;

    private void Update()
    {
        // Android back button or Escape key
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            _navigationService.HandleBackButton();
        }
    }
}
```

---

## BÖLÜM 2: OPTIMISTIC UI COMPONENTS

### 2.1 Loading State Component

```csharp
// Assets/Presentation/Components/OptimisticButton.cs
using System;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

/// <summary>
/// Button that handles optimistic operations with loading states.
/// </summary>
public class OptimisticButton : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private Button button;
    [SerializeField] private TextMeshProUGUI buttonText;
    [SerializeField] private GameObject loadingIndicator;
    [SerializeField] private Image buttonImage;

    [Header("States")]
    [SerializeField] private Color normalColor = Color.white;
    [SerializeField] private Color pendingColor = new Color(0.9f, 0.9f, 0.9f);
    [SerializeField] private Color successColor = new Color(0.5f, 1f, 0.5f);
    [SerializeField] private Color errorColor = new Color(1f, 0.5f, 0.5f);

    [Header("Animation")]
    [SerializeField] private float feedbackDuration = 0.3f;

    private string _originalText;
    private bool _isOperationInProgress;

    public event Action OnClick;

    private void Awake()
    {
        button.onClick.AddListener(HandleClick);
        _originalText = buttonText?.text ?? "";

        if (loadingIndicator != null)
            loadingIndicator.SetActive(false);
    }

    private void HandleClick()
    {
        if (_isOperationInProgress) return;
        OnClick?.Invoke();
    }

    /// <summary>
    /// Executes an optimistic operation with visual feedback.
    /// </summary>
    public async UniTask<OperationResult> ExecuteOptimisticAsync(
        Func<UniTask<OperationResult>> operation,
        string pendingText = null)
    {
        if (_isOperationInProgress)
            return OperationResult.ValidationError("Operation in progress");

        _isOperationInProgress = true;

        // 1. PENDING STATE
        SetPendingState(pendingText);

        try
        {
            // 2. EXECUTE
            var result = await operation();

            // 3. RESULT STATE
            if (result.IsSuccess)
            {
                await ShowSuccessStateAsync();
            }
            else
            {
                await ShowErrorStateAsync(result.Message);
            }

            return result;
        }
        catch (Exception ex)
        {
            await ShowErrorStateAsync(ex.Message);
            return OperationResult.NetworkError(ex);
        }
        finally
        {
            _isOperationInProgress = false;
            ResetState();
        }
    }

    private void SetPendingState(string pendingText)
    {
        button.interactable = false;

        if (loadingIndicator != null)
            loadingIndicator.SetActive(true);

        if (buttonText != null && !string.IsNullOrEmpty(pendingText))
            buttonText.text = pendingText;

        if (buttonImage != null)
            buttonImage.color = pendingColor;
    }

    private async UniTask ShowSuccessStateAsync()
    {
        if (loadingIndicator != null)
            loadingIndicator.SetActive(false);

        if (buttonImage != null)
        {
            buttonImage.color = successColor;
            await UniTask.Delay(TimeSpan.FromSeconds(feedbackDuration));
        }
    }

    private async UniTask ShowErrorStateAsync(string error)
    {
        if (loadingIndicator != null)
            loadingIndicator.SetActive(false);

        if (buttonImage != null)
        {
            buttonImage.color = errorColor;

            // Shake animation
            var originalPos = transform.localPosition;
            for (int i = 0; i < 3; i++)
            {
                transform.localPosition = originalPos + new Vector3(5, 0, 0);
                await UniTask.Delay(50);
                transform.localPosition = originalPos - new Vector3(5, 0, 0);
                await UniTask.Delay(50);
            }
            transform.localPosition = originalPos;

            await UniTask.Delay(TimeSpan.FromSeconds(feedbackDuration));
        }
    }

    private void ResetState()
    {
        button.interactable = true;

        if (loadingIndicator != null)
            loadingIndicator.SetActive(false);

        if (buttonText != null)
            buttonText.text = _originalText;

        if (buttonImage != null)
            buttonImage.color = normalColor;
    }
}
```

### 2.2 Currency Display with Rollback Animation

```csharp
// Assets/Presentation/Components/OptimisticCurrencyDisplay.cs
using System;
using Cysharp.Threading.Tasks;
using UnityEngine;
using TMPro;
using VContainer;

/// <summary>
/// Currency display that shows optimistic updates and rollback animations.
/// </summary>
public class OptimisticCurrencyDisplay : MonoBehaviour
{
    [Header("References")]
    [SerializeField] private TextMeshProUGUI amountText;
    [SerializeField] private RectTransform iconTransform;

    [Header("Animation")]
    [SerializeField] private float animationDuration = 0.3f;
    [SerializeField] private Color increaseColor = new Color(0.5f, 1f, 0.5f);
    [SerializeField] private Color decreaseColor = new Color(1f, 0.5f, 0.5f);
    [SerializeField] private Color rollbackColor = new Color(1f, 0.8f, 0.2f);

    [Inject] private ICurrencyService _currencyService;
    [Inject] private IMessageBus _messageBus;

    private CurrencyType _currencyType;
    private int _displayedAmount;
    private Color _originalColor;
    private IDisposable _subscription;

    private void Awake()
    {
        _originalColor = amountText.color;
    }

    public void Initialize(CurrencyType type)
    {
        _currencyType = type;
        _displayedAmount = _currencyService.GetBalance(type);
        UpdateDisplay(_displayedAmount);

        // Subscribe to changes
        _subscription = _messageBus.Subscribe<CurrencyChangedMessage>(OnCurrencyChanged);
    }

    private void OnDestroy()
    {
        _subscription?.Dispose();
    }

    private void OnCurrencyChanged(CurrencyChangedMessage msg)
    {
        if (msg.Type != _currencyType) return;

        AnimateChange(msg.PreviousAmount, msg.NewAmount, msg.IsOptimistic).Forget();
    }

    private async UniTaskVoid AnimateChange(int from, int to, bool isOptimistic)
    {
        var delta = to - from;
        var color = delta > 0 ? increaseColor : decreaseColor;

        // If this is a rollback (optimistic false and different from displayed)
        if (!isOptimistic && _displayedAmount != from)
        {
            color = rollbackColor;

            // Shake animation for rollback
            await PlayShakeAnimation();
        }

        // Animate number counting
        var elapsed = 0f;
        var startAmount = _displayedAmount;

        amountText.color = color;

        while (elapsed < animationDuration)
        {
            elapsed += Time.deltaTime;
            var t = elapsed / animationDuration;
            var easedT = 1f - Mathf.Pow(1f - t, 3f); // EaseOutCubic

            _displayedAmount = Mathf.RoundToInt(Mathf.Lerp(startAmount, to, easedT));
            UpdateDisplay(_displayedAmount);

            await UniTask.Yield();
        }

        _displayedAmount = to;
        UpdateDisplay(_displayedAmount);

        // Fade back to original color
        await amountText.DOColor(_originalColor, 0.2f).ToUniTask();
    }

    private async UniTask PlayShakeAnimation()
    {
        var originalPos = transform.localPosition;
        var shakeIntensity = 5f;

        for (int i = 0; i < 4; i++)
        {
            transform.localPosition = originalPos + new Vector3(
                UnityEngine.Random.Range(-shakeIntensity, shakeIntensity),
                0, 0);
            await UniTask.Delay(30);
        }

        transform.localPosition = originalPos;
    }

    private void UpdateDisplay(int amount)
    {
        amountText.text = FormatCurrency(amount);
    }

    private string FormatCurrency(int amount)
    {
        if (amount >= 1000000)
            return $"{amount / 1000000f:F1}M";
        if (amount >= 1000)
            return $"{amount / 1000f:F1}K";
        return amount.ToString();
    }
}
```

### 2.3 Optimistic List Item

```csharp
// Assets/Presentation/Components/OptimisticListItem.cs
using System;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// List item that shows pending/confirmed/rollback states.
/// </summary>
public class OptimisticListItem : MonoBehaviour
{
    [Header("Visual States")]
    [SerializeField] private CanvasGroup canvasGroup;
    [SerializeField] private Image backgroundImage;
    [SerializeField] private GameObject pendingIndicator;
    [SerializeField] private GameObject confirmedIndicator;

    [Header("Colors")]
    [SerializeField] private Color normalColor = Color.white;
    [SerializeField] private Color pendingColor = new Color(1f, 1f, 0.8f);
    [SerializeField] private Color errorColor = new Color(1f, 0.8f, 0.8f);

    public enum ItemState
    {
        Normal,
        Pending,
        Confirmed,
        Error
    }

    private ItemState _currentState = ItemState.Normal;

    public void SetState(ItemState state)
    {
        _currentState = state;

        switch (state)
        {
            case ItemState.Normal:
                SetNormalState();
                break;
            case ItemState.Pending:
                SetPendingState();
                break;
            case ItemState.Confirmed:
                SetConfirmedState().Forget();
                break;
            case ItemState.Error:
                SetErrorState().Forget();
                break;
        }
    }

    private void SetNormalState()
    {
        backgroundImage.color = normalColor;
        pendingIndicator?.SetActive(false);
        confirmedIndicator?.SetActive(false);
        canvasGroup.alpha = 1f;
    }

    private void SetPendingState()
    {
        backgroundImage.color = pendingColor;
        pendingIndicator?.SetActive(true);
        confirmedIndicator?.SetActive(false);

        // Subtle pulse animation
        canvasGroup.DOFade(0.8f, 0.5f)
            .SetLoops(-1, LoopType.Yoyo)
            .SetEase(Ease.InOutSine);
    }

    private async UniTaskVoid SetConfirmedState()
    {
        DOTween.Kill(canvasGroup);
        canvasGroup.alpha = 1f;

        backgroundImage.color = normalColor;
        pendingIndicator?.SetActive(false);
        confirmedIndicator?.SetActive(true);

        // Brief green flash
        await backgroundImage.DOColor(new Color(0.8f, 1f, 0.8f), 0.15f).ToUniTask();
        await backgroundImage.DOColor(normalColor, 0.15f).ToUniTask();

        await UniTask.Delay(1000);
        confirmedIndicator?.SetActive(false);
    }

    private async UniTaskVoid SetErrorState()
    {
        DOTween.Kill(canvasGroup);
        canvasGroup.alpha = 1f;

        pendingIndicator?.SetActive(false);
        confirmedIndicator?.SetActive(false);

        // Error shake and color
        backgroundImage.color = errorColor;

        var originalPos = transform.localPosition;
        for (int i = 0; i < 3; i++)
        {
            transform.localPosition = originalPos + new Vector3(5, 0, 0);
            await UniTask.Delay(40);
            transform.localPosition = originalPos - new Vector3(5, 0, 0);
            await UniTask.Delay(40);
        }
        transform.localPosition = originalPos;

        await UniTask.Delay(500);
        backgroundImage.color = normalColor;
    }
}
```

---

## BÖLÜM 3: GAMEPLAY REFACTORING

### 3.1 PlayerMovement Split Strategy

**Mevcut:** `PlayerMovement.cs` - 1014 satır, 10+ sorumluluk

**Yeni Yapı:**

```
Player/
├── Core/
│   ├── PlayerController.cs         # Main orchestrator (~100 lines)
│   ├── PlayerContext.cs            # Shared data/references (~50 lines)
│   └── IPlayerBehavior.cs          # Behavior interface
│
├── StateMachine/
│   ├── PlayerStateMachine.cs       # FSM manager (~150 lines)
│   ├── IPlayerState.cs             # State interface
│   └── States/
│       ├── IdleState.cs            # (~50 lines)
│       ├── RunningState.cs         # (~80 lines)
│       ├── JumpingState.cs         # (~100 lines)
│       ├── TeleportingState.cs     # (~80 lines)
│       ├── CoastingState.cs        # (~60 lines)
│       └── FrozenState.cs          # (~40 lines)
│
├── Behaviors/
│   ├── PlayerMovementBehavior.cs   # Core movement (~150 lines)
│   ├── PlayerJumpBehavior.cs       # Jump logic (~120 lines)
│   ├── PlayerTeleportBehavior.cs   # Teleport logic (~100 lines)
│   └── PlayerWallHitBehavior.cs    # Wall collision (~80 lines)
│
└── Input/
    └── PlayerInputHandler.cs       # Swipe/tap handling (~100 lines)
```

### 3.2 Player State Machine

```csharp
// Assets/Gameplay/Player/StateMachine/IPlayerState.cs
public interface IPlayerState
{
    void Enter(PlayerContext context);
    void Update(PlayerContext context);
    void FixedUpdate(PlayerContext context);
    void Exit(PlayerContext context);

    /// <summary>
    /// Handle input and return new state if transition needed.
    /// </summary>
    IPlayerState HandleInput(PlayerContext context, PlayerInput input);
}
```

```csharp
// Assets/Gameplay/Player/Core/PlayerContext.cs
using UnityEngine;

/// <summary>
/// Shared context for all player components.
/// Contains references and shared data.
/// </summary>
public class PlayerContext
{
    // Components
    public Transform Transform { get; }
    public Rigidbody Rigidbody { get; }
    public CharacterController CharacterController { get; }
    public PlayerAnimator Animator { get; }
    public PlayerStatHandler Stats { get; }

    // Movement settings
    public float MoveSpeed { get; set; }
    public float RotationSpeed { get; set; }
    public Vector3 CurrentDirection { get; set; }

    // State flags
    public bool IsGrounded { get; set; }
    public bool IsIntroPlaying { get; set; }
    public bool FirstMoveNotified { get; set; }

    // Events
    public event Action OnFirstMove;
    public event Action<Vector3> OnDirectionChanged;

    public PlayerContext(
        Transform transform,
        Rigidbody rigidbody,
        CharacterController characterController,
        PlayerAnimator animator,
        PlayerStatHandler stats)
    {
        Transform = transform;
        Rigidbody = rigidbody;
        CharacterController = characterController;
        Animator = animator;
        Stats = stats;
    }

    public void NotifyFirstMove()
    {
        if (FirstMoveNotified) return;
        FirstMoveNotified = true;
        OnFirstMove?.Invoke();
    }

    public void SetDirection(Vector3 direction)
    {
        if (CurrentDirection != direction)
        {
            CurrentDirection = direction;
            OnDirectionChanged?.Invoke(direction);
        }
    }
}
```

```csharp
// Assets/Gameplay/Player/StateMachine/PlayerStateMachine.cs
using UnityEngine;
using VContainer;

public class PlayerStateMachine
{
    private readonly PlayerContext _context;
    private readonly IMessageBus _messageBus;

    private IPlayerState _currentState;
    private IPlayerState _previousState;

    // Pre-instantiated states
    public IdleState IdleState { get; }
    public RunningState RunningState { get; }
    public JumpingState JumpingState { get; }
    public TeleportingState TeleportingState { get; }
    public CoastingState CoastingState { get; }
    public FrozenState FrozenState { get; }

    public IPlayerState CurrentState => _currentState;

    public PlayerStateMachine(PlayerContext context, IMessageBus messageBus)
    {
        _context = context;
        _messageBus = messageBus;

        // Create states
        IdleState = new IdleState(this);
        RunningState = new RunningState(this);
        JumpingState = new JumpingState(this);
        TeleportingState = new TeleportingState(this);
        CoastingState = new CoastingState(this);
        FrozenState = new FrozenState(this);

        // Start in idle
        ChangeState(IdleState);
    }

    public void Update()
    {
        _currentState?.Update(_context);
    }

    public void FixedUpdate()
    {
        _currentState?.FixedUpdate(_context);
    }

    public void HandleInput(PlayerInput input)
    {
        var newState = _currentState?.HandleInput(_context, input);
        if (newState != null && newState != _currentState)
        {
            ChangeState(newState);
        }
    }

    public void ChangeState(IPlayerState newState)
    {
        if (newState == null) return;

        _previousState = _currentState;
        _currentState?.Exit(_context);

        _currentState = newState;
        _currentState.Enter(_context);

        _messageBus.Publish(new PlayerStateChangedMessage(
            _previousState?.GetType().Name ?? "None",
            _currentState.GetType().Name
        ));
    }

    public void RevertToPreviousState()
    {
        if (_previousState != null)
        {
            ChangeState(_previousState);
        }
    }
}

public readonly struct PlayerStateChangedMessage : IMessage
{
    public string FromState { get; }
    public string ToState { get; }

    public PlayerStateChangedMessage(string from, string to)
    {
        FromState = from;
        ToState = to;
    }
}
```

### 3.3 Example State Implementation

```csharp
// Assets/Gameplay/Player/StateMachine/States/RunningState.cs
using UnityEngine;

public class RunningState : IPlayerState
{
    private readonly PlayerStateMachine _machine;

    public RunningState(PlayerStateMachine machine)
    {
        _machine = machine;
    }

    public void Enter(PlayerContext context)
    {
        context.Animator.SetRunning(true);
        context.NotifyFirstMove();
    }

    public void Update(PlayerContext context)
    {
        // Rotation towards movement direction
        if (context.CurrentDirection != Vector3.zero)
        {
            var targetRotation = Quaternion.LookRotation(context.CurrentDirection);
            context.Transform.rotation = Quaternion.Slerp(
                context.Transform.rotation,
                targetRotation,
                context.RotationSpeed * Time.deltaTime
            );
        }
    }

    public void FixedUpdate(PlayerContext context)
    {
        // Movement
        var velocity = context.CurrentDirection * context.MoveSpeed;
        context.CharacterController.Move(velocity * Time.fixedDeltaTime);

        // Ground check
        context.IsGrounded = context.CharacterController.isGrounded;
    }

    public void Exit(PlayerContext context)
    {
        context.Animator.SetRunning(false);
    }

    public IPlayerState HandleInput(PlayerContext context, PlayerInput input)
    {
        switch (input.Type)
        {
            case PlayerInputType.Swipe:
                // Change direction
                context.SetDirection(input.Direction);
                return null; // Stay in running

            case PlayerInputType.DoubleTap:
                // Jump
                return _machine.JumpingState;

            case PlayerInputType.TeleportTrigger:
                return _machine.TeleportingState;

            default:
                return null;
        }
    }
}
```

```csharp
// Assets/Gameplay/Player/StateMachine/States/JumpingState.cs
using UnityEngine;
using Cysharp.Threading.Tasks;

public class JumpingState : IPlayerState
{
    private readonly PlayerStateMachine _machine;

    private float _jumpStartTime;
    private float _jumpDuration = 0.5f;
    private float _jumpHeight = 2f;
    private Vector3 _startPosition;

    public JumpingState(PlayerStateMachine machine)
    {
        _machine = machine;
    }

    public void Enter(PlayerContext context)
    {
        _jumpStartTime = Time.time;
        _startPosition = context.Transform.position;

        context.Animator.TriggerJump();

        // Play jump sound/haptic
    }

    public void Update(PlayerContext context)
    {
        var elapsed = Time.time - _jumpStartTime;
        var normalizedTime = elapsed / _jumpDuration;

        if (normalizedTime >= 1f)
        {
            // Jump complete, return to running
            _machine.ChangeState(_machine.RunningState);
            return;
        }

        // Parabolic jump curve
        var jumpProgress = 1f - Mathf.Pow(2f * normalizedTime - 1f, 2f);
        var currentHeight = jumpProgress * _jumpHeight;

        var newPosition = context.Transform.position;
        newPosition.y = _startPosition.y + currentHeight;
        context.Transform.position = newPosition;
    }

    public void FixedUpdate(PlayerContext context)
    {
        // Continue moving forward while jumping
        var velocity = context.CurrentDirection * context.MoveSpeed;
        var horizontalMovement = new Vector3(velocity.x, 0, velocity.z);
        context.CharacterController.Move(horizontalMovement * Time.fixedDeltaTime);
    }

    public void Exit(PlayerContext context)
    {
        context.Animator.TriggerLand();
    }

    public IPlayerState HandleInput(PlayerContext context, PlayerInput input)
    {
        // Can change direction while jumping
        if (input.Type == PlayerInputType.Swipe)
        {
            context.SetDirection(input.Direction);
        }

        // Can't transition to other states while jumping
        return null;
    }
}
```

### 3.4 Player Input Handler

```csharp
// Assets/Gameplay/Player/Input/PlayerInputHandler.cs
using UnityEngine;
using VContainer;

public class PlayerInputHandler : MonoBehaviour
{
    [Header("Swipe Settings")]
    [SerializeField] private float minSwipeDistance = 50f;
    [SerializeField] private float maxSwipeTime = 0.3f;

    [Header("Double Tap Settings")]
    [SerializeField] private float doubleTapMaxDelay = 0.3f;

    private PlayerStateMachine _stateMachine;
    private PlayerContext _context;

    private Vector2 _touchStartPosition;
    private float _touchStartTime;
    private float _lastTapTime;

    [Inject]
    public void Construct(PlayerStateMachine stateMachine, PlayerContext context)
    {
        _stateMachine = stateMachine;
        _context = context;
    }

    private void Update()
    {
        if (_context.IsIntroPlaying) return;

        HandleTouchInput();
        HandleKeyboardInput(); // For testing
    }

    private void HandleTouchInput()
    {
        if (Input.touchCount == 0) return;

        var touch = Input.GetTouch(0);

        switch (touch.phase)
        {
            case TouchPhase.Began:
                _touchStartPosition = touch.position;
                _touchStartTime = Time.time;
                break;

            case TouchPhase.Ended:
                var touchDuration = Time.time - _touchStartTime;
                var swipeDistance = (touch.position - _touchStartPosition).magnitude;

                // Check for swipe
                if (swipeDistance >= minSwipeDistance && touchDuration <= maxSwipeTime)
                {
                    ProcessSwipe(touch.position - _touchStartPosition);
                }
                // Check for tap/double tap
                else if (swipeDistance < minSwipeDistance)
                {
                    if (Time.time - _lastTapTime <= doubleTapMaxDelay)
                    {
                        ProcessDoubleTap();
                        _lastTapTime = 0;
                    }
                    else
                    {
                        _lastTapTime = Time.time;
                    }
                }
                break;
        }
    }

    private void HandleKeyboardInput()
    {
#if UNITY_EDITOR
        if (Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.LeftArrow))
        {
            ProcessSwipe(Vector2.left);
        }
        else if (Input.GetKeyDown(KeyCode.D) || Input.GetKeyDown(KeyCode.RightArrow))
        {
            ProcessSwipe(Vector2.right);
        }
        else if (Input.GetKeyDown(KeyCode.Space))
        {
            ProcessDoubleTap();
        }
#endif
    }

    private void ProcessSwipe(Vector2 delta)
    {
        // Determine primary direction
        Vector3 direction;

        if (Mathf.Abs(delta.x) > Mathf.Abs(delta.y))
        {
            // Horizontal swipe
            direction = delta.x > 0 ? Vector3.right : Vector3.left;
        }
        else
        {
            // Vertical swipe (if needed)
            direction = delta.y > 0 ? Vector3.forward : Vector3.back;
        }

        // Transform to world space based on camera
        var cameraForward = Camera.main.transform.forward;
        cameraForward.y = 0;
        cameraForward.Normalize();

        var cameraRight = Camera.main.transform.right;
        cameraRight.y = 0;
        cameraRight.Normalize();

        var worldDirection = cameraForward * direction.z + cameraRight * direction.x;

        _stateMachine.HandleInput(new PlayerInput
        {
            Type = PlayerInputType.Swipe,
            Direction = worldDirection.normalized
        });
    }

    private void ProcessDoubleTap()
    {
        _stateMachine.HandleInput(new PlayerInput
        {
            Type = PlayerInputType.DoubleTap
        });
    }
}

public struct PlayerInput
{
    public PlayerInputType Type;
    public Vector3 Direction;
    public object Data;
}

public enum PlayerInputType
{
    None,
    Swipe,
    Tap,
    DoubleTap,
    TeleportTrigger
}
```

---

## BÖLÜM 4: GAMEPLAYMANAGER REFACTORING

### 4.1 Split Strategy

**Mevcut:** `GameplayManager.cs` - 752 satır

**Yeni Yapı:**

```
Gameplay/
├── GameplayManager.cs              # Orchestrator (~150 lines)
├── Session/
│   ├── GameplaySessionController.cs  # Session lifecycle (~200 lines)
│   └── SessionDataCollector.cs       # Stats collection (~100 lines)
│
├── Scoring/
│   └── ScoreManager.cs              # Score/currency tracking (~100 lines)
│
├── Spawning/
│   └── PlayerSpawnController.cs     # Player spawn logic (~80 lines)
│
└── Events/
    └── GameplayEvents.cs            # Event definitions (~50 lines)
```

### 4.2 Refactored GameplayManager

```csharp
// Assets/Gameplay/GameplayManager.cs
using Cysharp.Threading.Tasks;
using VContainer;
using VContainer.Unity;

/// <summary>
/// Orchestrates gameplay systems. Delegates to specialized controllers.
/// </summary>
public class GameplayManager : IStartable, ITickable
{
    private readonly IGameplaySessionController _sessionController;
    private readonly IScoreManager _scoreManager;
    private readonly IPlayerSpawnController _spawnController;
    private readonly IMessageBus _messageBus;
    private readonly ILogger _logger;

    private CompositeDisposable _subscriptions = new();

    public bool IsSessionActive => _sessionController.IsSessionActive;

    [Inject]
    public GameplayManager(
        IGameplaySessionController sessionController,
        IScoreManager scoreManager,
        IPlayerSpawnController spawnController,
        IMessageBus messageBus,
        ILogger logger)
    {
        _sessionController = sessionController;
        _scoreManager = scoreManager;
        _spawnController = spawnController;
        _messageBus = messageBus;
        _logger = logger;
    }

    public void Start()
    {
        // Subscribe to events
        _subscriptions.Add(_messageBus.Subscribe<GamePhaseChangedMessage>(OnPhaseChanged));
        _subscriptions.Add(_messageBus.Subscribe<CollectibleCollectedMessage>(OnCollectibleCollected));
        _subscriptions.Add(_messageBus.Subscribe<PlayerDiedMessage>(OnPlayerDied));

        _logger.Log("[GameplayManager] Initialized");
    }

    public void Tick()
    {
        if (IsSessionActive)
        {
            _scoreManager.UpdateDistanceScore(Time.deltaTime);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Public API
    // ═══════════════════════════════════════════════════════════════

    public async UniTask<bool> BeginSessionAsync(GameMode mode)
    {
        _logger.Log($"[GameplayManager] Beginning session: {mode}");

        var result = await _sessionController.BeginSessionAsync(mode);

        if (result.IsSuccess)
        {
            await _spawnController.SpawnPlayerAsync();
            _scoreManager.ResetScore();

            _messageBus.Publish(new GameplayStartedMessage(mode));
        }

        return result.IsSuccess;
    }

    public async UniTask EndSessionAsync(SessionEndReason reason)
    {
        _logger.Log($"[GameplayManager] Ending session: {reason}");

        var sessionData = _scoreManager.CollectSessionData();
        await _sessionController.EndSessionAsync(sessionData);

        _spawnController.DespawnPlayer();

        _messageBus.Publish(new GameplayEndedMessage(reason, sessionData));
    }

    public void PauseSession()
    {
        _sessionController.PauseSession();
        _messageBus.Publish(new GameplayPausedMessage());
    }

    public void ResumeSession()
    {
        _sessionController.ResumeSession();
        _messageBus.Publish(new GameplayResumedMessage());
    }

    // ═══════════════════════════════════════════════════════════════
    // Event Handlers
    // ═══════════════════════════════════════════════════════════════

    private void OnPhaseChanged(GamePhaseChangedMessage msg)
    {
        if (msg.NewPhase == GamePhase.Meta && IsSessionActive)
        {
            // Force end session when returning to meta
            EndSessionAsync(SessionEndReason.ReturnToMenu).Forget();
        }
    }

    private void OnCollectibleCollected(CollectibleCollectedMessage msg)
    {
        _scoreManager.AddCollectible(msg.Type, msg.Value);
    }

    private void OnPlayerDied(PlayerDiedMessage msg)
    {
        EndSessionAsync(SessionEndReason.PlayerDied).Forget();
    }

    public void Dispose()
    {
        _subscriptions.Dispose();
    }
}

// Event messages
public readonly struct GameplayStartedMessage : IMessage
{
    public GameMode Mode { get; }
    public GameplayStartedMessage(GameMode mode) => Mode = mode;
}

public readonly struct GameplayEndedMessage : IMessage
{
    public SessionEndReason Reason { get; }
    public SessionData Data { get; }
    public GameplayEndedMessage(SessionEndReason reason, SessionData data)
    {
        Reason = reason;
        Data = data;
    }
}

public readonly struct GameplayPausedMessage : IMessage { }
public readonly struct GameplayResumedMessage : IMessage { }

public enum SessionEndReason
{
    PlayerDied,
    ReturnToMenu,
    TimeUp,
    Completed
}
```

---

## BÖLÜM 5: MIGRATION CHECKLIST

### 5.1 UI Migration Steps

**Week 1: Navigation Framework**
- [ ] Create `UIScreenBase` and `UIPopupBase`
- [ ] Implement `NavigationService`
- [ ] Add `BackButtonHandler`
- [ ] Migrate `UIMainMenu` to `HomeScreen`

**Week 2: Optimistic Components**
- [ ] Create `OptimisticButton`
- [ ] Create `OptimisticCurrencyDisplay`
- [ ] Create `OptimisticListItem`
- [ ] Integrate with existing UI

**Week 3: Screen Migration**
- [ ] Migrate `UIShopPanel` → `ShopScreen`
- [ ] Migrate `UIProfileAndSettingsPanel` → `SettingsPopup`
- [ ] Migrate `UITaskPanel` → `TasksScreen`
- [ ] Test navigation flow

### 5.2 Gameplay Migration Steps

**Week 4: Player Refactoring**
- [ ] Create `PlayerContext`
- [ ] Create `PlayerStateMachine`
- [ ] Implement `IdleState`, `RunningState`
- [ ] Implement `JumpingState`, `TeleportingState`
- [ ] Create `PlayerInputHandler`
- [ ] Test player movement

**Week 5: Manager Cleanup**
- [ ] Split `GameplayManager`
- [ ] Create `GameplaySessionController`
- [ ] Create `ScoreManager`
- [ ] Create `PlayerSpawnController`
- [ ] Test gameplay flow

### 5.3 Final Integration

**Week 6: Polish**
- [ ] End-to-end testing
- [ ] Performance profiling
- [ ] Bug fixes
- [ ] Documentation updates

---

## BÖLÜM 6: FILE INVENTORY

Bu fazda oluşturulacak dosyalar:

```
Assets/Presentation/
├── Core/
│   ├── UIScreenBase.cs                 [YENİ]
│   ├── UIPopupBase.cs                  [YENİ]
│   └── CompositeDisposable.cs          [YENİ]
│
├── Navigation/
│   ├── NavigationService.cs            [YENİ]
│   └── BackButtonHandler.cs            [YENİ]
│
├── Components/
│   ├── OptimisticButton.cs             [YENİ]
│   ├── OptimisticCurrencyDisplay.cs    [YENİ]
│   └── OptimisticListItem.cs           [YENİ]
│
└── Screens/
    ├── Home/
    │   └── HomeScreen.cs               [YENİ - migrate from UIMainMenu]
    ├── Shop/
    │   └── ShopScreen.cs               [YENİ - migrate from UIShopPanel]
    └── Gameplay/
        └── GameplayScreen.cs           [YENİ - migrate from UIGamePlay]

Assets/Gameplay/
├── Player/
│   ├── Core/
│   │   ├── PlayerController.cs         [REFACTOR]
│   │   └── PlayerContext.cs            [YENİ]
│   ├── StateMachine/
│   │   ├── PlayerStateMachine.cs       [YENİ]
│   │   ├── IPlayerState.cs             [YENİ]
│   │   └── States/
│   │       ├── IdleState.cs            [YENİ]
│   │       ├── RunningState.cs         [YENİ]
│   │       ├── JumpingState.cs         [YENİ]
│   │       ├── TeleportingState.cs     [YENİ]
│   │       ├── CoastingState.cs        [YENİ]
│   │       └── FrozenState.cs          [YENİ]
│   └── Input/
│       └── PlayerInputHandler.cs       [YENİ]
│
├── Session/
│   ├── GameplaySessionController.cs    [YENİ]
│   └── SessionDataCollector.cs         [YENİ]
│
├── Scoring/
│   └── ScoreManager.cs                 [YENİ]
│
├── Spawning/
│   └── PlayerSpawnController.cs        [YENİ]
│
└── GameplayManager.cs                  [REFACTOR]
```

**Toplam:** ~30 yeni/refactor dosya

---

## SONUÇ

Bu üç fazlı refactoring tamamlandığında:

1. **Mimari:** Clean architecture, DI, event-driven
2. **Optimistic UX:** Instant feedback, graceful rollback
3. **Testability:** Mockable services, isolated components
4. **Maintainability:** Small, focused classes

**Önemli:** Her faz önceki fazlara bağımlıdır. Sırayla uygulayın.

---

*Bu döküman Phase 3 UI & Gameplay v1.0'dır.*
