<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta name="ad.size" content="width=320,height=480">
    <title>G-Roll</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #game {
            position: relative;
            width: 100%; height: 100%;
            max-width: 414px;
            margin: 0 auto;
            background: linear-gradient(180deg, #1a237e 0%, #7c4dff 100%);
        }
        #c {
            display: block;
            width: 100%;
            height: 100%;
        }
        #cta {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
            z-index: 100;
        }
        #cta .logo {
            font-size: 42px;
            font-weight: 900;
            color: #4CAF50;
            text-shadow: 0 4px 20px rgba(76, 175, 80, 0.5);
            letter-spacing: 4px;
        }
        #cta .score-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #cta .score {
            color: #FFD700;
            font-size: 56px;
            font-weight: bold;
            text-shadow: 0 4px 20px rgba(255, 215, 0, 0.5);
        }
        #cta .coin-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA000 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #FFA000;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }
        #cta .msg {
            color: #fff;
            font-size: 22px;
            font-weight: 500;
            opacity: 0.9;
        }
        #cta button {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            color: #fff;
            border: none;
            padding: 18px 56px;
            font-size: 22px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(76, 175, 80, 0.4);
            animation: pulse 1.5s infinite ease-in-out;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #cta button:active {
            transform: scale(0.95);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 8px 30px rgba(76, 175, 80, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 12px 40px rgba(76, 175, 80, 0.6); }
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="game">
        <canvas id="c"></canvas>
        <div id="cta">
            <div class="logo">G-ROLL</div>
            <div class="score-container">
                <span class="score" id="final-score">0</span>
                <div class="coin-icon">$</div>
            </div>
            <div class="msg">Ready for more?</div>
            <button onclick="handleCTA()">Download Now</button>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CFG = {
            // Canvas dimensions (logical)
            WIDTH: 360,
            HEIGHT: 640,
            PIXEL_RATIO: Math.min(window.devicePixelRatio || 1, 2),

            // Grid system
            CELL_SIZE: 40,
            GRID_WIDTH: 9,
            PLAYER_START: { x: 4, y: 3 },

            // Physics
            PLAYER_SPEED: 6,
            CAMERA_SPEED: 3.5,
            SWIPE_THRESHOLD: 25,

            // Timing
            GAME_DURATION: 15000,
            TUTORIAL_FADE_SPEED: 2,

            // Visual
            COLORS: {
                BG_TOP: '#1a237e',
                BG_BOTTOM: '#7c4dff',
                PLAYER: ['#81C784', '#2E7D32'],
                COIN: ['#FFD700', '#FF8F00'],
                WALL: ['#EF5350', '#C62828'],
                TEXT: '#FFFFFF',
                GRID: 'rgba(255,255,255,0.08)'
            },

            // Collision
            PLAYER_RADIUS: 0.4,
            COIN_RADIUS: 0.35,

            // Store URLs
            IOS_URL: 'https://apps.apple.com/app/g-roll/id6504637900',
            ANDROID_URL: 'https://play.google.com/store/apps/details?id=com.wikzllc.groll'
        };

        // ============================================
        // LEVEL DATA
        // ============================================
        const LEVEL = {
            coins: [
                // Easy start (y: 6-15)
                { x: 4, y: 6 },
                { x: 4, y: 9 },
                { x: 3, y: 12 },
                { x: 5, y: 12 },
                { x: 4, y: 15 },

                // Medium difficulty (y: 18-30)
                { x: 2, y: 19 },
                { x: 6, y: 19 },
                { x: 4, y: 22 },
                { x: 3, y: 25 },
                { x: 5, y: 25 },
                { x: 4, y: 28 },

                // Final section - coin rain (y: 33-50)
                { x: 3, y: 34 },
                { x: 4, y: 34 },
                { x: 5, y: 34 },
                { x: 2, y: 38 },
                { x: 6, y: 38 },
                { x: 4, y: 42 },
                { x: 3, y: 46 },
                { x: 5, y: 46 },
                { x: 4, y: 50 }
            ],

            walls: [
                // First obstacle group (y: 10)
                { x: 1, y: 10, w: 2, h: 1 },
                { x: 6, y: 10, w: 2, h: 1 },

                // Second obstacle - narrow passage (y: 17)
                { x: 0, y: 17, w: 3, h: 1 },
                { x: 6, y: 17, w: 3, h: 1 },

                // Third obstacle - zigzag (y: 30-32)
                { x: 2, y: 30, w: 2, h: 1 },
                { x: 5, y: 32, w: 2, h: 1 },

                // Fourth obstacle (y: 40)
                { x: 0, y: 40, w: 2, h: 1 },
                { x: 7, y: 40, w: 2, h: 1 }
            ]
        };

        // ============================================
        // SPRITE CACHE
        // ============================================
        const SpriteCache = {
            player: null,
            coin: null,
            wall: null,

            init() {
                this.player = this.createBallSprite(CFG.CELL_SIZE * 0.85, CFG.COLORS.PLAYER, false);
                this.coin = this.createBallSprite(CFG.CELL_SIZE * 0.55, CFG.COLORS.COIN, true);
            },

            createBallSprite(size, colors, hasDollar) {
                const canvas = document.createElement('canvas');
                const s = size * CFG.PIXEL_RATIO;
                canvas.width = s;
                canvas.height = s;
                const ctx = canvas.getContext('2d');

                // Radial gradient
                const gradient = ctx.createRadialGradient(
                    s * 0.35, s * 0.35, 0,
                    s * 0.5, s * 0.5, s * 0.5
                );
                gradient.addColorStop(0, colors[0]);
                gradient.addColorStop(1, colors[1]);

                // Main circle
                ctx.beginPath();
                ctx.arc(s / 2, s / 2, s / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Highlight
                ctx.beginPath();
                ctx.ellipse(s * 0.35, s * 0.32, s * 0.18, s * 0.1, -0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fill();

                // Dollar sign for coins
                if (hasDollar) {
                    ctx.fillStyle = colors[1];
                    ctx.font = `bold ${s * 0.45}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', s / 2, s / 2 + s * 0.02);
                }

                return canvas;
            }
        };

        // ============================================
        // INPUT HANDLER
        // ============================================
        const Input = {
            startPos: null,
            pendingDir: null,

            init() {
                const c = document.getElementById('c');

                // Touch events
                c.addEventListener('touchstart', this.onStart.bind(this), { passive: false });
                c.addEventListener('touchmove', this.onMove.bind(this), { passive: false });
                c.addEventListener('touchend', this.onEnd.bind(this), { passive: false });

                // Mouse fallback
                c.addEventListener('mousedown', this.onStart.bind(this));
                c.addEventListener('mousemove', this.onMove.bind(this));
                c.addEventListener('mouseup', this.onEnd.bind(this));
            },

            getPos(e) {
                const t = e.touches ? e.touches[0] : e;
                return { x: t.clientX, y: t.clientY };
            },

            onStart(e) {
                e.preventDefault();
                this.startPos = this.getPos(e);
                this.pendingDir = null;
            },

            onMove(e) {
                e.preventDefault();
                if (!this.startPos) return;

                const pos = this.getPos(e);
                const dx = pos.x - this.startPos.x;
                const dy = pos.y - this.startPos.y;

                if (Math.abs(dx) < CFG.SWIPE_THRESHOLD && Math.abs(dy) < CFG.SWIPE_THRESHOLD) return;

                // Cardinal direction (Unity SnapToCardinal)
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.pendingDir = dx > 0 ? 'RIGHT' : 'LEFT';
                } else {
                    this.pendingDir = dy > 0 ? 'DOWN' : 'UP';
                }
            },

            onEnd(e) {
                if (this.pendingDir) {
                    Player.setDirection(this.pendingDir);
                }
                this.startPos = null;
                this.pendingDir = null;
            }
        };

        // ============================================
        // PLAYER
        // ============================================
        const Player = {
            gridX: 4,
            gridY: 3,
            direction: { x: 0, y: 1 },
            scale: 1,
            squashTime: 0,

            init() {
                this.gridX = CFG.PLAYER_START.x;
                this.gridY = CFG.PLAYER_START.y;
                this.direction = { x: 0, y: 1 };
                this.scale = 1;
            },

            setDirection(dir) {
                const dirs = {
                    'UP': { x: 0, y: 1 },
                    'DOWN': { x: 0, y: -1 },
                    'LEFT': { x: -1, y: 0 },
                    'RIGHT': { x: 1, y: 0 }
                };

                const newDir = dirs[dir];
                if (!newDir) return;

                // Check if direction changed
                if (newDir.x !== this.direction.x || newDir.y !== this.direction.y) {
                    this.direction = newDir;
                    this.squashTime = 0.15; // Squash effect on direction change
                }

                // First input starts the game
                if (Game.state === 'tutorial') {
                    Game.startPlaying();
                }
            },

            update(dt) {
                if (Game.state !== 'playing') return;

                // Movement
                const speed = CFG.PLAYER_SPEED * dt;
                this.gridX += this.direction.x * speed;
                this.gridY += this.direction.y * speed;

                // Clamp to grid bounds
                this.gridX = Math.max(0.5, Math.min(CFG.GRID_WIDTH - 0.5, this.gridX));

                // Squash effect decay
                if (this.squashTime > 0) {
                    this.squashTime = Math.max(0, this.squashTime - dt);
                }
            },

            getWorldPos() {
                return {
                    x: (this.gridX - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2,
                    y: this.gridY * CFG.CELL_SIZE
                };
            }
        };

        // ============================================
        // CAMERA
        // ============================================
        const Camera = {
            y: 0,
            shakeAmount: 0,
            shakeDecay: 0,

            init() {
                this.y = Player.gridY - 5;
                this.shakeAmount = 0;
            },

            update(dt) {
                if (Game.state !== 'playing') return;

                // Follow player with offset
                const targetY = Player.gridY - 5;
                this.y += (targetY - this.y) * 0.1;

                // Also auto-scroll forward
                this.y += CFG.CAMERA_SPEED * dt;

                // Shake decay
                if (this.shakeAmount > 0) {
                    this.shakeAmount *= 0.85;
                    if (this.shakeAmount < 0.5) this.shakeAmount = 0;
                }
            },

            shake() {
                this.shakeAmount = 15;
            },

            getOffset() {
                const shake = this.shakeAmount > 0
                    ? (Math.random() - 0.5) * this.shakeAmount
                    : 0;
                return {
                    x: shake,
                    y: this.y * CFG.CELL_SIZE + shake
                };
            }
        };

        // ============================================
        // ENTITIES (Coins & Walls)
        // ============================================
        const Entities = {
            coins: [],
            walls: [],

            init() {
                this.coins = [];
                this.walls = [];

                // Load level data
                LEVEL.coins.forEach(c => {
                    this.coins.push({
                        x: c.x,
                        y: c.y,
                        collected: false,
                        scale: 1,
                        alpha: 1,
                        rotation: Math.random() * Math.PI * 2
                    });
                });

                LEVEL.walls.forEach(w => {
                    this.walls.push({
                        x: w.x,
                        y: w.y,
                        w: w.w || 1,
                        h: w.h || 1,
                        active: true
                    });
                });
            },

            update(dt) {
                const time = performance.now() / 1000;

                // Coin animations
                this.coins.forEach(coin => {
                    if (coin.collected) {
                        // Collected animation
                        coin.scale += dt * 3;
                        coin.alpha -= dt * 5;
                    } else {
                        // Idle animation
                        coin.scale = 1 + Math.sin(time * 4 + coin.y) * 0.1;
                        coin.rotation += dt * 2;
                    }
                });

                // Remove fully faded coins
                this.coins = this.coins.filter(c => !c.collected || c.alpha > 0);
            }
        };

        // ============================================
        // COLLISION
        // ============================================
        const Collision = {
            check() {
                if (Game.state !== 'playing') return;

                const px = Player.gridX;
                const py = Player.gridY;

                // Coin collision
                Entities.coins.forEach(coin => {
                    if (coin.collected) return;

                    const dx = px - coin.x;
                    const dy = py - coin.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < CFG.PLAYER_RADIUS + CFG.COIN_RADIUS) {
                        this.collectCoin(coin);
                    }
                });

                // Wall collision
                Entities.walls.forEach(wall => {
                    if (!wall.active) return;

                    // AABB
                    const pr = CFG.PLAYER_RADIUS;
                    if (px + pr > wall.x &&
                        px - pr < wall.x + wall.w &&
                        py + pr > wall.y &&
                        py - pr < wall.y + wall.h) {
                        this.hitWall();
                    }
                });
            },

            collectCoin(coin) {
                coin.collected = true;
                Game.score++;
                UI.addCoinFX(coin.x, coin.y);
            },

            hitWall() {
                if (Game.state !== 'playing') return;
                Game.state = 'gameover';
                Camera.shake();
                Player.squashTime = 0.3;
                setTimeout(() => Game.showCTA(), 1200);
            }
        };

        // ============================================
        // UI
        // ============================================
        const UI = {
            tutorialAlpha: 1,
            coinFX: [],

            addCoinFX(gridX, gridY) {
                const worldX = (gridX - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                const camOffset = Camera.getOffset();
                const screenY = CFG.HEIGHT - (gridY * CFG.CELL_SIZE - camOffset.y);

                this.coinFX.push({
                    x: worldX,
                    y: screenY,
                    alpha: 1,
                    vy: -3
                });
            },

            update(dt) {
                // Tutorial fade
                if (Game.state === 'playing' && this.tutorialAlpha > 0) {
                    this.tutorialAlpha = Math.max(0, this.tutorialAlpha - dt * CFG.TUTORIAL_FADE_SPEED);
                }

                // Coin FX update
                this.coinFX = this.coinFX.filter(fx => {
                    fx.y += fx.vy;
                    fx.alpha -= 0.03;
                    return fx.alpha > 0;
                });
            },

            draw(ctx) {
                // Score
                ctx.save();
                ctx.fillStyle = CFG.COLORS.TEXT;
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetY = 2;

                const scoreX = 24;
                const scoreY = 42;
                ctx.fillText(Game.score.toString(), scoreX, scoreY);

                // Coin icon next to score
                const iconSize = 28;
                ctx.drawImage(SpriteCache.coin, scoreX + 45, scoreY - 20, iconSize, iconSize);
                ctx.restore();

                // Timer bar
                const progress = Math.max(0, (CFG.GAME_DURATION - Game.elapsed) / CFG.GAME_DURATION);
                const barX = 24;
                const barY = 58;
                const barW = CFG.WIDTH - 48;
                const barH = 8;

                // Bar background
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW, barH, 4);
                ctx.fill();

                // Bar fill
                const gradient = ctx.createLinearGradient(barX, 0, barX + barW, 0);
                gradient.addColorStop(0, '#4CAF50');
                gradient.addColorStop(1, '#81C784');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(barX, barY, barW * progress, barH, 4);
                ctx.fill();

                // Coin pickup FX
                this.coinFX.forEach(fx => {
                    ctx.globalAlpha = fx.alpha;
                    ctx.fillStyle = CFG.COLORS.COIN[0];
                    ctx.font = 'bold 22px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+1', fx.x, fx.y);
                });
                ctx.globalAlpha = 1;

                // Tutorial overlay
                if (this.tutorialAlpha > 0 && (Game.state === 'tutorial' || Game.state === 'loading')) {
                    this.drawTutorial(ctx);
                }
            },

            drawTutorial(ctx) {
                const alpha = this.tutorialAlpha;

                // Dim overlay
                ctx.fillStyle = `rgba(0,0,0,${0.4 * alpha})`;
                ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

                ctx.globalAlpha = alpha;

                // Title
                ctx.fillStyle = CFG.COLORS.TEXT;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 8;
                ctx.fillText('Swipe to Move', CFG.WIDTH / 2, CFG.HEIGHT / 2 - 60);

                // Animated hand
                const time = performance.now() / 1000;
                const handX = CFG.WIDTH / 2 + Math.sin(time * 2.5) * 60;
                const handY = CFG.HEIGHT / 2 + 20;

                // Draw swipe line
                ctx.strokeStyle = `rgba(255,255,255,${0.5 * alpha})`;
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(CFG.WIDTH / 2 - 60, handY);
                ctx.lineTo(CFG.WIDTH / 2 + 60, handY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Hand emoji
                ctx.font = '52px Arial';
                ctx.fillText('\u{1F446}', handX, handY + 10);

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        };

        // ============================================
        // RENDERER
        // ============================================
        const Render = {
            ctx: null,
            canvas: null,

            init() {
                this.canvas = document.getElementById('c');
                this.canvas.width = CFG.WIDTH * CFG.PIXEL_RATIO;
                this.canvas.height = CFG.HEIGHT * CFG.PIXEL_RATIO;
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';

                this.ctx = this.canvas.getContext('2d');
                this.ctx.scale(CFG.PIXEL_RATIO, CFG.PIXEL_RATIO);
            },

            draw() {
                const ctx = this.ctx;
                const camOffset = Camera.getOffset();

                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, CFG.HEIGHT);
                gradient.addColorStop(0, CFG.COLORS.BG_TOP);
                gradient.addColorStop(1, CFG.COLORS.BG_BOTTOM);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CFG.WIDTH, CFG.HEIGHT);

                // Grid lines
                ctx.strokeStyle = CFG.COLORS.GRID;
                ctx.lineWidth = 1;

                // Vertical lines
                for (let i = 0; i <= CFG.GRID_WIDTH; i++) {
                    const x = (i - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, CFG.HEIGHT);
                    ctx.stroke();
                }

                // Horizontal lines (scrolling)
                const gridOffsetY = camOffset.y % CFG.CELL_SIZE;
                for (let i = -1; i <= CFG.HEIGHT / CFG.CELL_SIZE + 1; i++) {
                    const y = CFG.HEIGHT - i * CFG.CELL_SIZE + gridOffsetY;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(CFG.WIDTH, y);
                    ctx.stroke();
                }

                // Save for camera transform
                ctx.save();
                ctx.translate(camOffset.x, 0);

                // Draw walls
                this.drawWalls(ctx, camOffset);

                // Draw coins
                this.drawCoins(ctx, camOffset);

                // Draw player
                this.drawPlayer(ctx, camOffset);

                ctx.restore();

                // UI (fixed position)
                UI.draw(ctx);
            },

            drawWalls(ctx, camOffset) {
                Entities.walls.forEach(wall => {
                    // Viewport culling
                    const screenY = CFG.HEIGHT - (wall.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE * 2 || screenY > CFG.HEIGHT + CFG.CELL_SIZE * 2) return;

                    const x = (wall.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = wall.y * CFG.CELL_SIZE;
                    const w = wall.w * CFG.CELL_SIZE;
                    const h = wall.h * CFG.CELL_SIZE;

                    // Gradient fill
                    const gradient = ctx.createLinearGradient(x, CFG.HEIGHT - (y - camOffset.y), x, CFG.HEIGHT - (y - camOffset.y) - h);
                    gradient.addColorStop(0, CFG.COLORS.WALL[0]);
                    gradient.addColorStop(1, CFG.COLORS.WALL[1]);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(
                        x - w / 2 + 2,
                        CFG.HEIGHT - (y - camOffset.y) - h + 2,
                        w - 4,
                        h - 4,
                        6
                    );
                    ctx.fill();

                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.roundRect(
                        x - w / 2 + 4,
                        CFG.HEIGHT - (y - camOffset.y) - h + 4,
                        w - 8,
                        (h - 8) * 0.3,
                        4
                    );
                    ctx.fill();
                });
            },

            drawCoins(ctx, camOffset) {
                Entities.coins.forEach(coin => {
                    // Viewport culling
                    const screenY = CFG.HEIGHT - (coin.y * CFG.CELL_SIZE - camOffset.y);
                    if (screenY < -CFG.CELL_SIZE || screenY > CFG.HEIGHT + CFG.CELL_SIZE) return;

                    const x = (coin.x - CFG.GRID_WIDTH / 2 + 0.5) * CFG.CELL_SIZE + CFG.WIDTH / 2;
                    const y = coin.y * CFG.CELL_SIZE;
                    const size = CFG.CELL_SIZE * 0.55 * coin.scale;

                    ctx.globalAlpha = coin.alpha;

                    // Glow effect
                    if (!coin.collected) {
                        ctx.shadowColor = CFG.COLORS.COIN[0];
                        ctx.shadowBlur = 15;
                    }

                    ctx.drawImage(
                        SpriteCache.coin,
                        x - size / 2,
                        CFG.HEIGHT - (y - camOffset.y) - size / 2,
                        size,
                        size
                    );

                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                });
            },

            drawPlayer(ctx, camOffset) {
                const pos = Player.getWorldPos();
                const size = CFG.CELL_SIZE * 0.85;

                // Squash effect
                let scaleX = 1;
                let scaleY = 1;
                if (Player.squashTime > 0) {
                    const t = Player.squashTime / 0.15;
                    if (Player.direction.x !== 0) {
                        scaleX = 1 - t * 0.2;
                        scaleY = 1 + t * 0.15;
                    } else {
                        scaleX = 1 + t * 0.15;
                        scaleY = 1 - t * 0.2;
                    }
                }

                const drawX = pos.x;
                const drawY = CFG.HEIGHT - (pos.y - camOffset.y);

                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.scale(scaleX, scaleY);

                // Glow
                ctx.shadowColor = CFG.COLORS.PLAYER[0];
                ctx.shadowBlur = 20;

                ctx.drawImage(
                    SpriteCache.player,
                    -size / 2,
                    -size / 2,
                    size,
                    size
                );

                ctx.restore();
            }
        };

        // ============================================
        // GAME CONTROLLER
        // ============================================
        const Game = {
            state: 'loading',
            score: 0,
            elapsed: 0,
            lastTime: 0,

            init() {
                SpriteCache.init();
                Render.init();
                Input.init();
                Player.init();
                Camera.init();
                Entities.init();

                this.state = 'tutorial';
                this.score = 0;
                this.elapsed = 0;
                this.lastTime = performance.now();

                requestAnimationFrame(this.loop.bind(this));
            },

            startPlaying() {
                this.state = 'playing';
                this.elapsed = 0;
            },

            showCTA() {
                this.state = 'cta';
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('cta').style.display = 'flex';
            },

            loop(time) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.1);
                this.lastTime = time;

                // Update
                if (this.state === 'playing') {
                    this.elapsed += dt * 1000;

                    // Time's up = success
                    if (this.elapsed >= CFG.GAME_DURATION) {
                        this.state = 'success';
                        setTimeout(() => this.showCTA(), 1500);
                    }
                }

                Player.update(dt);
                Camera.update(dt);
                Entities.update(dt);
                UI.update(dt);
                Collision.check();

                // Render
                Render.draw();

                // Continue loop
                if (this.state !== 'cta') {
                    requestAnimationFrame(this.loop.bind(this));
                }
            }
        };

        // ============================================
        // CTA HANDLER
        // ============================================
        window.handleCTA = function() {
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            const url = isIOS ? CFG.IOS_URL : CFG.ANDROID_URL;

            // MRAID support for ad networks
            if (typeof mraid !== 'undefined' && mraid.open) {
                mraid.open(url);
            } else {
                window.open(url, '_blank');
            }
        };

        // ============================================
        // START
        // ============================================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => Game.init());
        } else {
            Game.init();
        }
    })();
    </script>
</body>
</html>
